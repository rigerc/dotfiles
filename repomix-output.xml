This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: .chezmoidata, .chezmoiexternals, .chezmoiscripts, dot_claude, dot_config, dot_local/bin, dot_local/bin/ingest.sh, dot_shortcuts, dot_shortcuts/ssh.sh, dot_ssh, dot_ssh/config, pwsh, utils, .chezmoi.toml.tmpl, .chezmoiignore, .install-essentials.sh, CLAUDE.md, dot_aliases, dot_bashrc, dot_claude.json, dot_env.tmpl, dot_gitconfig.tmpl, dot_tmux.conf, dot_zprofile, dot_zshrc
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.chezmoi.toml.tmpl
.chezmoidata/packages.yaml
.chezmoiexternals/externals.toml
.chezmoiignore
.chezmoiscripts/run_after_install_post_install.sh.tmpl
.chezmoiscripts/run_common.sh.tmpl
.chezmoiscripts/run_onchange_before_00_install_packages.sh.tmpl
.chezmoiscripts/run_onchange_enable_ssh_service.sh.tmpl
.install-essentials.sh
CLAUDE.md
dot_aliases
dot_bashrc
dot_claude.json
dot_claude/settings.json
dot_config/alacritty/alacritty.toml
dot_config/fish/completions/fisher.fish
dot_config/fish/completions/git-forgit.fish
dot_config/fish/completions/zoxide.fish
dot_config/fish/conf.d/__async_prompt.fish
dot_config/fish/conf.d/_pure_init.fish
dot_config/fish/conf.d/abbr_tips.fish
dot_config/fish/conf.d/pure.fish
dot_config/fish/conf.d/zoxide.fish
dot_config/fish/config.fish
dot_config/fish/fish_plugins
dot_config/fish/fish_variables
dot_config/fish/functions/__abbr_tips_bind_newline.fish
dot_config/fish/functions/__abbr_tips_bind_space.fish
dot_config/fish/functions/__abbr_tips_clean.fish
dot_config/fish/functions/__abbr_tips_init.fish
dot_config/fish/functions/_pure_check_availability.fish
dot_config/fish/functions/_pure_check_for_new_release.fish
dot_config/fish/functions/_pure_detect_container_by_cgroup_method.fish
dot_config/fish/functions/_pure_detect_container_by_pid_method.fish
dot_config/fish/functions/_pure_format_time.fish
dot_config/fish/functions/_pure_get_prompt_symbol.fish
dot_config/fish/functions/_pure_is_inside_container.fish
dot_config/fish/functions/_pure_is_single_line_prompt.fish
dot_config/fish/functions/_pure_k8s_context.fish
dot_config/fish/functions/_pure_k8s_namespace.fish
dot_config/fish/functions/_pure_parse_directory.fish
dot_config/fish/functions/_pure_parse_git_branch.fish
dot_config/fish/functions/_pure_place_iterm2_prompt_mark.fish
dot_config/fish/functions/_pure_prefix_root_prompt.fish
dot_config/fish/functions/_pure_print_prompt_rows.fish
dot_config/fish/functions/_pure_print_prompt.fish
dot_config/fish/functions/_pure_prompt_aws_profile.fish
dot_config/fish/functions/_pure_prompt_beginning.fish
dot_config/fish/functions/_pure_prompt_command_duration.fish
dot_config/fish/functions/_pure_prompt_container.fish
dot_config/fish/functions/_pure_prompt_current_folder.fish
dot_config/fish/functions/_pure_prompt_ending.fish
dot_config/fish/functions/_pure_prompt_first_line.fish
dot_config/fish/functions/_pure_prompt_git_branch.fish
dot_config/fish/functions/_pure_prompt_git_dirty.fish
dot_config/fish/functions/_pure_prompt_git_pending_commits.fish
dot_config/fish/functions/_pure_prompt_git_stash.fish
dot_config/fish/functions/_pure_prompt_git.fish
dot_config/fish/functions/_pure_prompt_jobs.fish
dot_config/fish/functions/_pure_prompt_k8s.fish
dot_config/fish/functions/_pure_prompt_new_line.fish
dot_config/fish/functions/_pure_prompt_nixdevshell.fish
dot_config/fish/functions/_pure_prompt_ssh.fish
dot_config/fish/functions/_pure_prompt_symbol.fish
dot_config/fish/functions/_pure_prompt_system_time.fish
dot_config/fish/functions/_pure_prompt_vimode.fish
dot_config/fish/functions/_pure_prompt_virtualenv.fish
dot_config/fish/functions/_pure_prompt.fish
dot_config/fish/functions/_pure_set_color.fish
dot_config/fish/functions/_pure_set_default.fish
dot_config/fish/functions/_pure_string_width.fish
dot_config/fish/functions/_pure_user_at_host.fish
dot_config/fish/functions/fish_greeting.fish
dot_config/fish/functions/fish_mode_prompt.fish
dot_config/fish/functions/fish_prompt.fish
dot_config/fish/functions/fish_title.fish
dot_config/fish/functions/fish_user_key_bindings.fish
dot_config/fish/functions/fisher.fish
dot_config/fish/functions/zoxide.fish
dot_config/mods/mods.yml
dot_config/nano/nanorc
dot_config/opencode/opencode.json
dot_config/starship.toml
dot_config/zsh/aliases.zsh
dot_env.tmpl
dot_gitconfig.tmpl
dot_local/bin/ingest.sh
dot_shortcuts/ssh.sh
dot_ssh/config
dot_tmux.conf
dot_zprofile
dot_zshrc
pwsh/install_wsl/Install-WSLArchLinux.ps1
pwsh/install_wsl/Modules/WSL-Chezmoi.psm1
pwsh/install_wsl/Modules/WSL-Command.psm1
pwsh/install_wsl/Modules/WSL-Helpers.psm1
pwsh/install_wsl/Modules/WSL-Input.psm1
pwsh/install_wsl/Modules/WSL-Install.psd1
pwsh/install_wsl/Modules/WSL-Logging.psm1
pwsh/install_wsl/Modules/WSL-Management.psm1
pwsh/install_wsl/Modules/WSL-PackageManager.psm1
pwsh/install_wsl/Modules/WSL-SSH.psm1
pwsh/install_wsl/Modules/WSL-SystemSetup.psm1
pwsh/install_wsl/Modules/WSL-UserManagement.psm1
pwsh/install_wsl/Modules/WSL-Validation.psm1
pwsh/install_wsl/Modules/WSL-Workflow.psm1
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="dot_config/nano/nanorc">
# Colors
set titlecolor brightblue
set statuscolor brightblue
set errorcolor brightred
set selectedcolor brightred
set stripecolor brightyellow
set numbercolor brightblue
set keycolor brightblue
set functioncolor brightcyan
</file>

<file path="dot_zprofile">
# eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
</file>

<file path=".chezmoiscripts/run_after_install_post_install.sh.tmpl">
#!{{ lookPath "bash" }}
set -uo pipefail

# Source common functions
source "{{ .chezmoi.sourceDir }}/.chezmoiscripts/common.sh"

# Configuration

readonly TMUX_PLUGIN_PATH="$HOME/.config/tmux/plugins/tpm/bin/install_plugins"
readonly ALACRITTY_SOURCE="$HOME/.config/alacritty/alacritty.toml"
readonly ALACRITTY_TARGET="/mnt/c/Users/bondg/appdata/roaming/alacritty/alacritty.toml"
readonly ALACRITTY_THEMES_SOURCE="$HOME/.config/alacritty/themes"
readonly ALACRITTY_THEMES_TARGET="/mnt/c/Users/bondg/appdata/roaming/alacritty/themes"

# Set default shell
set_default_shell() {
    local shell_name="$1"
    
    if ! command_exists "$shell_name"; then
        log_error "$shell_name not found"
        return 1
    fi
    
    local shell_path
    shell_path=$(command -v "$shell_name")
    
    # Add to /etc/shells if needed
    if ! grep -q "^${shell_path}$" /etc/shells 2>/dev/null; then
        echo "$shell_path" | sudo tee -a /etc/shells >/dev/null
        log_success "Added $shell_name to /etc/shells"
    else
        log_success "$shell_name already in /etc/shells"
    fi
    
    # Only set as default shell on Android
    if is_android; then
        if [[ "$SHELL" != "$shell_path" ]]; then
            log_info "Changing default shell to $shell_name..."
            if chsh -s "$shell_path"; then
                # Verify the change worked
                local new_shell
                new_shell=$(getent passwd "$USER" | cut -d: -f7)
                if [[ "$new_shell" == "$shell_path" ]]; then
                    log_success "Successfully set $shell_name as default shell"
                else
                    log_error "chsh command succeeded but shell was not changed (expected: $shell_path, got: $new_shell)"
                    return 1
                fi
            else
                log_error "Failed to change default shell to $shell_name"
                return 1
            fi
        else
            log_success "$shell_name already set as default shell"
        fi
    else
        log_success "$shell_name is available (shell change skipped - only done on Android)"
    fi
    
    return 0
}

setup_zsh() {
    log_step "Setting up Zsh as default shell"
    
    if ! command_exists zsh; then
        log_warning "Zsh not installed, skipping"
        return 0
    fi
    
    if set_default_shell "zsh"; then
        log_success "Zsh setup completed"
        return 0
    else
        log_error "Zsh setup failed"
        return 1
    fi
}

setup_fish() {
    log_step "Setting up Fish as default shell"
    
    if ! command_exists fish; then
        log_warning "Fish not installed, skipping"
        return 0
    fi
    
    if set_default_shell "fish"; then
        log_success "Fish setup completed"
        return 0
    else
        log_error "Fish setup failed"
        return 1
    fi
}

cleanup_lazyvim() {
    log_step "Cleaning up LazyVim"
    
    # Check if nvim config exists
    if [[ ! -d "$HOME/.config/nvim" ]]; then
        log_success "LazyVim not installed, nothing to clean"
        return 0
    fi
    
    if [[ -d "$HOME/.config/nvim/.git" ]]; then
        if rm -rf "$HOME/.config/nvim/.git"; then
            log_success "LazyVim .git directory removed"
        else
            log_error "Failed to remove LazyVim .git directory"
            return 1
        fi
    else
        log_success "LazyVim already clean (no .git directory)"
    fi
    return 0
}

rebuild_fonts() {
    log_step "Rebuilding font cache"
    
    if ! command_exists fc-cache; then
        log_warning "fc-cache not found, skipping"
        return 0
    fi
    
    # Check if fonts directory exists and has fonts
    local fonts_exist=false
    for font_dir in "$HOME/.local/share/fonts" "$HOME/.fonts" "/usr/share/fonts" "/usr/local/share/fonts"; do
        if [[ -d "$font_dir" ]] && [[ -n "$(find "$font_dir" -type f 2>/dev/null)" ]]; then
            fonts_exist=true
            break
        fi
    done
    
    if [[ "$fonts_exist" == false ]]; then
        log_success "No custom fonts found, cache rebuild not needed"
        return 0
    fi
    
    log_info "Rebuilding font cache..."
    if fc-cache -f -v >/dev/null 2>&1; then
        log_success "Font cache rebuilt"
        return 0
    else
        log_warning "Font cache rebuild had issues"
        return 1
    fi
}

generate_locales() {
    log_step "Generating system locales"
    
    if ! command_exists locale-gen; then
        log_warning "locale-gen not found, skipping"
        return 0
    fi
    
    # Check if locale is already generated
    if locale -a 2>/dev/null | grep -qi "^en_US.utf8$"; then
        log_success "en_US.UTF-8 locale already generated"
        return 0
    fi
    
    log_info "Generating locales..."
    sudo sed -i 's:#en_US.UTF-8 UTF-8:en_US.UTF-8 UTF-8:g' /etc/locale.gen 2>/dev/null || true
    
    if sudo locale-gen >/dev/null 2>&1; then
        log_success "Locales generated"
        return 0
    else
        log_warning "Locale generation had issues"
        return 1
    fi
}

install_tmux_plugins() {
    log_step "Installing Tmux plugins"
    
    # Check if tmux is installed
    if ! command_exists tmux; then
        log_warning "Tmux not installed, skipping plugin installation"
        return 0
    fi
    
    # Check if TPM is installed
    if [[ ! -x "$TMUX_PLUGIN_PATH" ]]; then
        log_warning "Tmux plugin manager not found at $TMUX_PLUGIN_PATH"
        return 0
    fi
    
    # Check if plugins are already installed
    local plugin_dir="$HOME/.config/tmux/plugins"
    if [[ -d "$plugin_dir" ]]; then
        local plugin_count
        plugin_count=$(find "$plugin_dir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
        if [[ $plugin_count -gt 1 ]]; then
            log_success "Tmux plugins already installed ($plugin_count plugins found)"
            return 0
        fi
    fi
    
    log_info "Installing Tmux plugins..."
    if "$TMUX_PLUGIN_PATH" >/dev/null 2>&1; then
        log_success "Tmux plugins installed"
        return 0
    else
        log_warning "Tmux plugin installation had issues"
        return 1
    fi
}

copy_alacritty_config() {
    log_step "Copying Alacritty configuration"
    
    if ! is_wsl; then
        log_success "Not running on WSL, Alacritty copy not needed"
        return 0
    fi
    
    local success=true
    local any_copied=false
    
    # Copy alacritty.toml
    if [[ -f "$ALACRITTY_SOURCE" ]]; then
        # Check if file already exists and is identical
        if [[ -f "$ALACRITTY_TARGET" ]] && cmp -s "$ALACRITTY_SOURCE" "$ALACRITTY_TARGET"; then
            log_success "Alacritty config already up to date"
        else
            if safe_copy "$ALACRITTY_SOURCE" "$ALACRITTY_TARGET"; then
                log_success "Alacritty config copied"
                any_copied=true
            else
                log_warning "Failed to copy Alacritty config"
                success=false
            fi
        fi
    else
        log_warning "Alacritty config not found at $ALACRITTY_SOURCE"
        success=false
    fi
    
    # Copy themes directory
    if [[ -d "$ALACRITTY_THEMES_SOURCE" ]]; then
        # Check if themes directory exists and has content
        if [[ -d "$ALACRITTY_THEMES_TARGET" ]]; then
            local source_count target_count
            source_count=$(find "$ALACRITTY_THEMES_SOURCE" -type f 2>/dev/null | wc -l)
            target_count=$(find "$ALACRITTY_THEMES_TARGET" -type f 2>/dev/null | wc -l)
            
            if [[ $source_count -eq $target_count ]] && [[ $source_count -gt 0 ]]; then
                log_success "Alacritty themes already up to date ($target_count themes)"
            else
                if safe_copy "$ALACRITTY_THEMES_SOURCE" "$ALACRITTY_THEMES_TARGET"; then
                    log_success "Alacritty themes copied"
                    any_copied=true
                else
                    log_warning "Failed to copy Alacritty themes"
                    success=false
                fi
            fi
        else
            if safe_copy "$ALACRITTY_THEMES_SOURCE" "$ALACRITTY_THEMES_TARGET"; then
                log_success "Alacritty themes copied"
                any_copied=true
            else
                log_warning "Failed to copy Alacritty themes"
                success=false
            fi
        fi
    else
        log_warning "Alacritty themes not found at $ALACRITTY_THEMES_SOURCE"
        success=false
    fi
    
    if [[ "$any_copied" == false ]] && [[ "$success" == true ]]; then
        log_success "Alacritty configuration already synchronized"
    fi
    
    [[ "$success" == true ]]
}

main() {
    log_header "Running Post-Installation Operations"
    
    # Load environment
    source "$HOME/.bashrc" 2>/dev/null || true
    load_homebrew || true
    
    log_info "Running as user: $(whoami)"
    echo ""
    
    # Track overall success
    local all_success=true
    
    # Define operations based on platform
    local operations=()
    
    if is_android; then
        log_info "Detected Android platform"
        operations=(
            "setup_fish"
        )
    elif is_arch; then
        log_info "Detected Arch Linux platform"
        operations=(
            "setup_zsh"
            "setup_fish"
            "cleanup_lazyvim"
            "rebuild_fonts"
            "generate_locales"
            "install_tmux_plugins"
            "copy_alacritty_config"
        )
    else
        log_warning "Unknown platform, running default operations"
        operations=(
            "setup_zsh"
            "setup_fish"
            "cleanup_lazyvim"
            "rebuild_fonts"
            "generate_locales"
            "install_tmux_plugins"
            "copy_alacritty_config"
        )
    fi
    
    echo ""
    
    # Run platform-specific operations
    for operation in "${operations[@]}"; do
        if ! $operation; then
            all_success=false
        fi
        echo ""
    done
    
    # Print final status
    if [[ "$all_success" == true ]]; then
        log_header "All Post-Installation Operations Completed Successfully!"
        echo ""
        log_warning "Please restart your shell to apply all changes"
        log_info "Run: exec \$SHELL"
        return 0
    else
        log_header "Post-Installation Completed With Some Warnings"
        echo ""
        log_info "Review the output above for details"
        log_warning "Please restart your shell to apply changes"
        return 0  # Don't fail the script for warnings
    fi
}

main "$@"
</file>

<file path=".chezmoiscripts/run_common.sh.tmpl">
#!{{ lookPath "bash" }}
# =============================================================================
# .chezmoiscripts/.common.sh
# Shared utility functions for all chezmoi scripts
# =============================================================================

set -uo pipefail

# -----------------------------------------------------------------------------
# Color Definitions
# -----------------------------------------------------------------------------
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# -----------------------------------------------------------------------------
# Logging Functions
# -----------------------------------------------------------------------------
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_step() {
    echo -e "${YELLOW}───────────────────────────────────────────────────${NC}" >&2
    echo -e "${YELLOW}$*${NC}" >&2
}

log_header() {
    echo -e "${GREEN}═══════════════════════════════════════════════════${NC}" >&2
    echo -e "${GREEN}$*${NC}" >&2
    echo -e "${GREEN}═══════════════════════════════════════════════════${NC}" >&2
}

# -----------------------------------------------------------------------------
# Error Handling
# -----------------------------------------------------------------------------
error_handler() {
    local line_num=$1
    log_error "Script failed at line ${line_num}"
    exit 1
}

trap 'error_handler ${LINENO}' ERR

# -----------------------------------------------------------------------------
# Utility Functions
# -----------------------------------------------------------------------------

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Create directory if it doesn't exist
ensure_directory() {
    local dir="$1"
    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir"
        log_info "Created directory: $dir"
    fi
}

# Safe file copy with directory creation
safe_copy() {
    local source="$1"
    local target="$2"
    
    if [[ ! -e "$source" ]]; then
        log_warning "Source not found: $source"
        return 1
    fi
    
    local target_dir
    target_dir=$(dirname "$target")
    ensure_directory "$target_dir"
    
    if [[ -d "$source" ]]; then
        # Directory copy
        [[ -d "$target" ]] && rm -rf "$target"
        cp -r "$source" "$target"
    else
        # File copy
        cp "$source" "$target"
    fi
    
    if [[ -e "$target" ]]; then
        log_success "Copied to $target"
        return 0
    else
        log_error "Copy failed: $target not found after copy"
        return 1
    fi
}

# Check if running on Arch Linux
is_arch() {
    [[ -f /etc/os-release ]] && grep -qi "^ID=arch$" /etc/os-release
}

# Check if running on WSL
is_wsl() {
    [[ -f /proc/version ]] && grep -qi microsoft /proc/version
}

# Check if running on Android
is_android() {
    [[ -d /system/app || -d /system/priv-app ]] || [[ "$(uname -o 2>/dev/null)" == "Android" ]]
}

# -----------------------------------------------------------------------------
# Homebrew Functions
# -----------------------------------------------------------------------------

# Standard Homebrew installation paths
readonly HOMEBREW_PATHS=(
    "$HOME/.linuxbrew"
    "/home/linuxbrew/.linuxbrew"
    "/opt/homebrew"  # Apple Silicon
    "/usr/local"     # Intel Mac
)

# Find Homebrew installation
find_homebrew() {
    for path in "${HOMEBREW_PATHS[@]}"; do
        if [[ -d "$path" && -x "$path/bin/brew" ]]; then
            echo "$path"
            return 0
        fi
    done
    return 1
}

# Check if Homebrew is in PATH
is_homebrew_available() {
    command_exists brew
}

# Load Homebrew environment
load_homebrew() {
    if is_homebrew_available; then
        return 0
    fi
    
    local homebrew_path
    if homebrew_path=$(find_homebrew); then
        eval "$($homebrew_path/bin/brew shellenv)"
        return 0
    fi
    
    return 1
}

install_homebrew() {
    log_header "Installing Homebrew"
    
    # Check if already installed
    if is_homebrew_available; then
        log_success "Homebrew already installed: $(command -v brew)"
        log_info "Version: $(brew --version | head -n1)"
        return 0
    fi
    
    # Try to find existing installation
    if load_homebrew; then
        log_success "Found existing Homebrew installation"
        brew --version | head -n1
        return 0
    fi
    
    # Install Homebrew
    log_info "Installing Homebrew..."
    export NONINTERACTIVE=1
    
    if /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then
        log_success "Homebrew installed"
    else
        log_error "Homebrew installation failed"
        return 1
    fi
    
    # Load newly installed Homebrew
    if ! load_homebrew; then
        log_error "Cannot find Homebrew after installation"
        log_info "Standard locations checked:"
        for path in "${HOMEBREW_PATHS[@]}"; do
            log_info "  - $path"
        done
        return 1
    fi
    
    # Update Homebrew
    log_info "Updating Homebrew..."
    brew update --force --quiet
    
    # Fix zsh permissions if needed
    if command_exists zsh; then
        chmod -R go-w "$(brew --prefix)/share/zsh" 2>/dev/null || true
        log_info "Fixed zsh permissions"
    fi
    
    log_success "Homebrew installation completed"
    log_info "Location: $(command -v brew)"
    log_info "Version: $(brew --version | head -n1)"
}

# -----------------------------------------------------------------------------
# NPM Functions
# -----------------------------------------------------------------------------

# Standard NPM installation paths (Node.js)
readonly NODE_PATHS=(
    "$HOME/.nvm/versions/node"
    "$HOME/.volta/tools/image/node"
    "$HOME/.asdf/installs/nodejs"
    "/usr/local/bin"
    "/usr/bin"
)

# Find npm installation
find_npm() {
    # First check if npm is already in PATH
    if command_exists npm; then
        command -v npm
        return 0
    fi
    
    # Check standard Node.js installation paths
    for path in "${NODE_PATHS[@]}"; do
        if [[ -d "$path" ]]; then
            # Find the latest version directory if exists
            local npm_bin
            if [[ -f "$path/bin/npm" ]]; then
                npm_bin="$path/bin/npm"
            elif [[ -d "$path" ]]; then
                # Find latest version in version directories (nvm style)
                local latest_version
                latest_version=$(find "$path" -maxdepth 1 -type d -name "v*" | sort -V | tail -n1)
                if [[ -n "$latest_version" && -f "$latest_version/bin/npm" ]]; then
                    npm_bin="$latest_version/bin/npm"
                fi
            fi
            
            if [[ -n "$npm_bin" && -x "$npm_bin" ]]; then
                echo "$npm_bin"
                return 0
            fi
        fi
    done
    return 1
}

# Check if npm is available
is_npm_available() {
    command_exists npm
}

# Load npm environment
load_npm() {
    if is_npm_available; then
        return 0
    fi
    
    local npm_path
    if npm_path=$(find_npm); then
        local npm_dir
        npm_dir=$(dirname "$npm_path")
        export PATH="$npm_dir:$PATH"
        return 0
    fi
    
    return 1
}

# Install Node.js and npm
install_npm() {
    log_header "Installing Node.js and npm"
    
    # Check if npm is already available
    if is_npm_available; then
        log_success "npm already installed: $(command -v npm)"
        log_info "Version: $(npm --version)"
        log_info "Node.js: $(node --version)"
        return 0
    fi
    
    # Try to find existing installation
    if load_npm; then
        log_success "Found existing npm installation"
        log_info "npm version: $(npm --version)"
        log_info "Node.js version: $(node --version)"
        return 0
    fi
    
    # Determine installation method based on system
    log_info "Installing Node.js and npm..."
    
    # Try using system package manager first
    if command_exists pacman; then
        log_info "Installing via pacman..."
        sudo pacman -S --noconfirm --needed nodejs npm >/dev/null
    elif command_exists apt-get; then
        log_info "Installing via apt..."
        sudo apt-get update >/dev/null
        sudo apt-get install -y nodejs npm >/dev/null
    elif command_exists yum; then
        log_info "Installing via yum..."
        sudo yum install -y nodejs npm >/dev/null
    elif command_exists brew; then
        log_info "Installing via Homebrew..."
        brew install node >/dev/null
    else
        log_error "No supported package manager found"
        log_info "Please install Node.js manually from https://nodejs.org/"
        return 1
    fi
    
    # Verify installation
    if ! load_npm; then
        log_error "Cannot find npm after installation"
        return 1
    fi
    
    log_success "Node.js and npm installation completed"
    log_info "npm location: $(command -v npm)"
    log_info "npm version: $(npm --version)"
    log_info "Node.js version: $(node --version)"
}

# =============================================================================
# END OF .common.sh
# =============================================================================
</file>

<file path="dot_claude.json">
{
  "hasCompletedOnboarding": true
}
</file>

<file path="dot_claude/settings.json">
{
  "env": {
    "ANTHROPIC_BASE_URL": "https://api.z.ai/api/anthropic",
    "API_TIMEOUT_MS": "3000000",
    "ANTHROPIC_DEFAULT_HAIKU_MODEL": "glm-4.5-air",
    "ANTHROPIC_DEFAULT_SONNET_MODEL": "glm-4.6",
    "ANTHROPIC_DEFAULT_OPUS_MODEL": "glm-4.6"
  },
  "mcpServers": {
    "context7": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y",
        "@upstash/context7-mcp"
      ],
      "env": {}
    }
  }
}
</file>

<file path="dot_config/fish/completions/fisher.fish">
complete --command fisher --exclusive --long help --description "Print help"
complete --command fisher --exclusive --long version --description "Print version"
complete --command fisher --exclusive --condition __fish_use_subcommand --arguments install --description "Install plugins"
complete --command fisher --exclusive --condition __fish_use_subcommand --arguments update --description "Update installed plugins"
complete --command fisher --exclusive --condition __fish_use_subcommand --arguments remove --description "Remove installed plugins"
complete --command fisher --exclusive --condition __fish_use_subcommand --arguments list --description "List installed plugins matching regex"
complete --command fisher --exclusive --condition "__fish_seen_subcommand_from update remove" --arguments "(fisher list)"
</file>

<file path="dot_config/fish/completions/git-forgit.fish">
#
# forgit completions for fish plugin
#
# Place this file inside your <fish_config_dir>/completions/ directory.
# It's usually located at ~/.config/fish/completions/. The file is lazily
# sourced when git-forgit command or forgit subcommand of git is invoked.

function __fish_forgit_needs_subcommand
    for subcmd in add blame branch_delete checkout_branch checkout_commit checkout_file checkout_tag \
        cherry_pick cherry_pick_from_branch clean diff fixup ignore log reflog rebase reset_head \
        revert_commit reword squash stash_show stash_push
        if contains -- $subcmd (commandline -opc)
            return 1
        end
    end
    return 0
end

# Load helper functions in git completion file
not functions -q __fish_git && source $__fish_data_dir/completions/git.fish

# No file completion by default
complete -c git-forgit -x

complete -c git-forgit -n __fish_forgit_needs_subcommand -a add -d 'git add selector'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a blame -d 'git blame viewer'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a branch_delete -d 'git branch deletion selector'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a checkout_branch -d 'git checkout branch selector'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a checkout_commit -d 'git checkout commit selector'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a checkout_file -d 'git checkout-file selector'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a checkout_tag -d 'git checkout tag selector'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a cherry_pick -d 'git cherry-picking'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a cherry_pick_from_branch -d 'git cherry-picking with interactive branch selection'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a clean -d 'git clean selector'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a diff -d 'git diff viewer'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a fixup -d 'git fixup'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a ignore -d 'git ignore generator'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a log -d 'git commit viewer'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a reflog -d 'git reflog viewer'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a rebase -d 'git rebase'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a reset_head -d 'git reset HEAD (unstage) selector'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a revert_commit -d 'git revert commit selector'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a reword -d 'git fixup=reword'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a show -d 'git show viewer'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a squash -d 'git squash'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a stash_show -d 'git stash viewer'
complete -c git-forgit -n __fish_forgit_needs_subcommand -a stash_push -d 'git stash push selector'

complete -c git-forgit -n '__fish_seen_subcommand_from add' -a "(complete -C 'git add ')"
complete -c git-forgit -n '__fish_seen_subcommand_from branch_delete' -a "(__fish_git_local_branches)"
complete -c git-forgit -n '__fish_seen_subcommand_from checkout_branch' -a "(complete -C 'git switch ')"
complete -c git-forgit -n '__fish_seen_subcommand_from checkout_commit' -a "(__fish_git_commits)"
complete -c git-forgit -n '__fish_seen_subcommand_from checkout_file' -a "(__fish_git_files modified)"
complete -c git-forgit -n '__fish_seen_subcommand_from checkout_tag' -a "(__fish_git_tags)" -d Tag
complete -c git-forgit -n '__fish_seen_subcommand_from cherry_pick' -a "(complete -C 'git cherry-pick ')"
complete -c git-forgit -n '__fish_seen_subcommand_from clean' -a "(__fish_git_files untracked ignored)"
complete -c git-forgit -n '__fish_seen_subcommand_from diff' -a "(complete -C 'git diff ')"
complete -c git-forgit -n '__fish_seen_subcommand_from fixup' -a "(complete -C 'git log ')"
complete -c git-forgit -n '__fish_seen_subcommand_from log' -a "(complete -C 'git log ')"
complete -c git-forgit -n '__fish_seen_subcommand_from reflog' -a "(complete -C 'git reflog ')"
complete -c git-forgit -n '__fish_seen_subcommand_from rebase' -a "(complete -C 'git rebase ')"
complete -c git-forgit -n '__fish_seen_subcommand_from reset_head' -a "(__fish_git_files all-staged)"
complete -c git-forgit -n '__fish_seen_subcommand_from revert_commit' -a "(__fish_git_commits)"
complete -c git-forgit -n '__fish_seen_subcommand_from reword' -a "(complete -C 'git log ')"
complete -c git-forgit -n '__fish_seen_subcommand_from show' -a "(complete -C 'git show ')"
complete -c git-forgit -n '__fish_seen_subcommand_from squash' -a "(complete -C 'git log ')"
complete -c git-forgit -n '__fish_seen_subcommand_from stash_show' -a "(__fish_git_complete_stashes)"
complete -c git-forgit -n '__fish_seen_subcommand_from stash_push' -a "(__fish_git_files modified deleted modified-staged-deleted)"
</file>

<file path="dot_config/fish/completions/zoxide.fish">
set -l commands add help import init query remove

# disable normal all-files completion
complete -c zoxide -f

# onyl show base options if none was used already
complete -c zoxide -n __fish_use_subcommand -a add -d "Add a new directory or increment its rank"
complete -c zoxide -n __fish_use_subcommand -a help -d "Prints this message or the help of the given subcommand(s)"
complete -c zoxide -n __fish_use_subcommand -a import -d "Import from z database"
complete -c zoxide -n __fish_use_subcommand -a init -d "Generates shell configuration"
complete -c zoxide -n __fish_use_subcommand -a query -d "Search for a directory"
complete -c zoxide -n __fish_use_subcommand -a remove -d "Remove a directory"

# zoxide add
complete -c zoxide -n "_zoxide_equals_first_token add" -n "__fish_is_nth_token 2" -a "(__fish_complete_directories)"

# zoxide help
complete -c zoxide -n "_zoxide_equals_first_token help" -n "__fish_is_nth_token 2" -a "$commands"

# zoxide import
complete -c zoxide -r -F -n "_zoxide_equals_first_token import" -n "__fish_is_nth_token 2"
complete -c zoxide -r -n "_zoxide_equals_first_token import" -l merge -d "Merge entries into existing database"

# zoxide init
set -l initshells bash fish posix powershell zsh
complete -c zoxide -n "_zoxide_equals_first_token init" -n "__fish_is_nth_token 2" -a "$initshells"
complete -c zoxide -n "_zoxide_equals_first_token init" -l cmd -d "Renames the 'z' command and corresponding aliases [default: z]"
complete -c zoxide -n "_zoxide_equals_first_token init" -l hook -a "none prompt pwd" -d "Chooses event on which an entry is added to the database [default: pwd]"
complete -c zoxide -n "_zoxide_equals_first_token init" -l no-aliases -d "Prevents zoxide from defining any commands other than 'z'"

# zoxide query
complete -c zoxide -r -n "_zoxide_equals_first_token query" -s i -l interactive -d "Opens an interactive selection menu using fzf"
complete -c zoxide -r -n "_zoxide_equals_first_token query" -s l -l list -d "List all matching directories"
complete -c zoxide -r -n "_zoxide_equals_first_token query" -s s -l score -d "Display score along with result"

# zoxide remove
complete -c zoxide -n "_zoxide_equals_first_token remove" -n "__fish_is_nth_token 2" -a "(zoxide query -l)"

# Always possible
complete -c zoxide -x -s h -l help -d "Prints help information"
complete -c zoxide -x -s V -l version -d "Prints version information"
</file>

<file path="dot_config/fish/conf.d/__async_prompt.fish">
status is-interactive
or exit 0

set -g __async_prompt_tmpdir (command mktemp -d)

# Setup after the user defined prompt functions are loaded.
function __async_prompt_setup_on_startup --on-event fish_prompt
    functions -e (status current-function)
    if test "$async_prompt_enable" = 0
        return 0
    end

    for func in (__async_prompt_config_functions)
        function $func -V func
            test -e $__async_prompt_tmpdir'/'$fish_pid'_'$func
            and cat $__async_prompt_tmpdir'/'$fish_pid'_'$func
        end
    end
end

function __async_prompt_keep_last_pipestatus
    set -g __async_prompt_last_pipestatus $pipestatus
end

not set -q async_prompt_on_variable
and set async_prompt_on_variable fish_bind_mode
function __async_prompt_fire --on-event fish_prompt (for var in $async_prompt_on_variable; printf '%s\n' --on-variable $var; end)
    for func in (__async_prompt_config_functions)
        set -l tmpfile $__async_prompt_tmpdir'/'$fish_pid'_'$func

        if functions -q $func'_loading_indicator' && test -e $tmpfile
            read -zl last_prompt <$tmpfile
            eval (string escape -- $func'_loading_indicator' "$last_prompt") >$tmpfile
        end

        __async_prompt_config_inherit_variables | __async_prompt_spawn \
            $func' | read -z prompt
            echo -n $prompt >'$tmpfile
    end
end

function __async_prompt_spawn -a cmd
    set -l envs
    begin
        while read line
            switch "$line"
                case fish_bind_mode
                    echo fish_bind_mode $fish_bind_mode
                case FISH_VERSION PWD _ history 'fish_*' hostname version status_generation
                case status pipestatus
                    echo pipestatus $__async_prompt_last_pipestatus
                case SHLVL
                    set envs $envs SHLVL=$SHLVL
                case '*'
                    echo $line (string escape -- $$line)
            end
        end
    end | read -lz vars
    echo $vars | env $envs fish -c '
    function __async_prompt_signal
        kill -s "'(__async_prompt_config_internal_signal)'" '$fish_pid' 2>/dev/null
    end
    while read -a line
        test -z "$line"
        and continue

        if test "$line[1]" = pipestatus
            set -f _pipestatus $line[2..]
        else
            eval set "$line"
        end
    end

    function __async_prompt_set_status
        return $argv
    end
    if set -q _pipestatus
        switch (count $_pipestatus)
            case 1
                __async_prompt_set_status $_pipestatus[1]
            case 2
                __async_prompt_set_status $_pipestatus[1] \
                | __async_prompt_set_status $_pipestatus[2]
            case 3
                __async_prompt_set_status $_pipestatus[1] \
                | __async_prompt_set_status $_pipestatus[2] \
                | __async_prompt_set_status $_pipestatus[3]
            case 4
                __async_prompt_set_status $_pipestatus[1] \
                | __async_prompt_set_status $_pipestatus[2] \
                | __async_prompt_set_status $_pipestatus[3] \
                | __async_prompt_set_status $_pipestatus[4]
            case 5
                __async_prompt_set_status $_pipestatus[1] \
                | __async_prompt_set_status $_pipestatus[2] \
                | __async_prompt_set_status $_pipestatus[3] \
                | __async_prompt_set_status $_pipestatus[4] \
                | __async_prompt_set_status $_pipestatus[5]
            case 6
                __async_prompt_set_status $_pipestatus[1] \
                | __async_prompt_set_status $_pipestatus[2] \
                | __async_prompt_set_status $_pipestatus[3] \
                | __async_prompt_set_status $_pipestatus[4] \
                | __async_prompt_set_status $_pipestatus[5] \
                | __async_prompt_set_status $_pipestatus[6]
            case 7
                __async_prompt_set_status $_pipestatus[1] \
                | __async_prompt_set_status $_pipestatus[2] \
                | __async_prompt_set_status $_pipestatus[3] \
                | __async_prompt_set_status $_pipestatus[4] \
                | __async_prompt_set_status $_pipestatus[5] \
                | __async_prompt_set_status $_pipestatus[6] \
                | __async_prompt_set_status $_pipestatus[7]
            case 8
                __async_prompt_set_status $_pipestatus[1] \
                | __async_prompt_set_status $_pipestatus[2] \
                | __async_prompt_set_status $_pipestatus[3] \
                | __async_prompt_set_status $_pipestatus[4] \
                | __async_prompt_set_status $_pipestatus[5] \
                | __async_prompt_set_status $_pipestatus[6] \
                | __async_prompt_set_status $_pipestatus[7] \
                | __async_prompt_set_status $_pipestatus[8]
            default
                __async_prompt_set_status $_pipestatus[1] \
                | __async_prompt_set_status $_pipestatus[2] \
                | __async_prompt_set_status $_pipestatus[3] \
                | __async_prompt_set_status $_pipestatus[4] \
                | __async_prompt_set_status $_pipestatus[5] \
                | __async_prompt_set_status $_pipestatus[6] \
                | __async_prompt_set_status $_pipestatus[7] \
                | __async_prompt_set_status $_pipestatus[8] \
                | __async_prompt_set_status $_pipestatus[-1]
        end
    else
        true
    end
    '$cmd'
    __async_prompt_signal' &
    if test (__async_prompt_config_disown) = 1
        disown
    end
end

function __async_prompt_config_inherit_variables
    if set -q async_prompt_inherit_variables
        if test "$async_prompt_inherit_variables" = all
            set -ng
        else
            for item in $async_prompt_inherit_variables
                echo $item
            end
        end
    else
        echo CMD_DURATION
        echo fish_bind_mode
        echo pipestatus
        echo SHLVL
        echo status
    end
end

function __async_prompt_config_functions
    set -l funcs (
        if set -q async_prompt_functions
            string join \n $async_prompt_functions
        else
            echo fish_prompt
            echo fish_right_prompt
        end
    )
    for func in $funcs
        functions -q "$func"
        or continue

        echo $func
    end
end

function __async_prompt_config_internal_signal
    if test -z "$async_prompt_signal_number"
        echo SIGUSR1
    else
        echo "$async_prompt_signal_number"
    end
end

function __async_prompt_config_disown
    if test -z "$async_prompt_disown"
        echo 1
    else
        echo "$async_prompt_disown"
    end
end

function __async_prompt_repaint_prompt --on-signal (__async_prompt_config_internal_signal)
    commandline -f repaint >/dev/null 2>/dev/null
end

function __async_prompt_tmpdir_cleanup --on-event fish_exit
    rm -rf "$__async_prompt_tmpdir"
end
</file>

<file path="dot_config/fish/conf.d/_pure_init.fish">
# Deactivate the default virtualenv prompt so that we can add our own
set --global --export VIRTUAL_ENV_DISABLE_PROMPT 1

# Whether or not is a fresh session
set --global _pure_fresh_session true

# Register `_pure_prompt_new_line` as an event handler for `fish_prompt`
for fpath in $fish_function_path;
    test -e $fpath/_pure_prompt_new_line.fish && source $fpath/_pure_prompt_new_line.fish
end


function _pure_uninstall --on-event pure_uninstall \
    --description 'Fisher handler to uninstall pure prompt'
    
    rm -f $__fish_config_dir/conf.d/pure.fish

    # backup fish_prompt and fish_title to default
    cp $__fish_config_dir/functions/fish_prompt{,.pure-backup}.fish
    cp $__fish_config_dir/functions/fish_title{,.pure-backup}.fish

    # erase existing fish_prompt and fish_title to default
    functions --erase fish_prompt
    functions --erase fish_title
    # restore fish_prompt and fish_title to default
    cp {$__fish_data_dir,$__fish_config_dir}/functions/fish_prompt.fish
    cp {$__fish_data_dir,$__fish_config_dir}/functions/fish_title.fish

    # refresh fish_prompt and fish_title definitions
    source $__fish_data_dir/functions/fish_prompt.fish
    source $__fish_data_dir/functions/fish_title.fish

    # erase _pure* variables
    set --names \
        | string replace --filter --regex '(^_?pure)' 'set --erase $1' \
        | source
    # erase _pure* functions
    functions --names --all \
        | string replace --filter --regex '(^_?pure)' 'functions --erase $1' \
        | source
    # delete _pure* files
    for file in $__fish_config_dir/{functions,conf.d}/_pure_*
        rm -f $file
    end
end
</file>

<file path="dot_config/fish/conf.d/abbr_tips.fish">
for mode in default insert
    bind --mode $mode " " __abbr_tips_bind_space
    bind --mode $mode \n __abbr_tips_bind_newline
    bind --mode $mode \r __abbr_tips_bind_newline
end

set -g __abbr_tips_used 0

# Trim simple/double quotes from args
function trim_value
    echo "$argv" | string trim --left --right --chars '"\'' | string join ' '
end

function __abbr_tips_install --on-event abbr_tips_install
    # Regexes used to find abbreviation inside command
    # Only the first matching group will be tested as an abbr
    set -Ux ABBR_TIPS_REGEXES
    set -a ABBR_TIPS_REGEXES '(^(\w+\s+)+(-{1,2})\w+)(\s\S+)'
    set -a ABBR_TIPS_REGEXES '(^(\s?(\w-?)+){3}).*'
    set -a ABBR_TIPS_REGEXES '(^(\s?(\w-?)+){2}).*'
    set -a ABBR_TIPS_REGEXES '(^(\s?(\w-?)+){1}).*'

    set -Ux ABBR_TIPS_PROMPT "\n💡 \e[1m{{ .abbr }}\e[0m => {{ .cmd }}"
    set -gx ABBR_TIPS_AUTO_UPDATE background

    __abbr_tips_init
end

function __abbr_tips --on-event fish_postexec -d "Abbreviation reminder for the current command"
    set -l command (string split ' ' -- "$argv")
    set -l cmd (string replace -r -a '\\s+' ' ' -- "$argv" )

    # Update abbreviations lists when adding/removing abbreviations
    if test "$command[1]" = abbr
        # Parse args as abbr options
        argparse --name abbr --ignore-unknown a/add e/erase g/global U/universal -- $command

        if set -q _flag_a
            and not contains -- "$argv[2]" $__ABBR_TIPS_KEYS
            set -a __ABBR_TIPS_KEYS "$argv[2]"
            set -a __ABBR_TIPS_VALUES (trim_value "$argv[3..-1]")
        else if set -q _flag_e
            and set -l abb (contains -i -- "$argv[2]" $__ABBR_TIPS_KEYS)
            set -e __ABBR_TIPS_KEYS[$abb]
            set -e __ABBR_TIPS_VALUES[$abb]
        end
    else if test "$command[1]" = alias
        # Update abbreviations list when adding aliases
        set -l alias_key
        set -l alias_value

        # Parse args as `alias` options
        argparse --name alias --ignore-unknown s/save -- $command

        if string match -q '*=*' -- "$argv[2]"
            set command_split (string split '=' -- $argv[2])
            set alias_key "a__$command_split[1]"
            set alias_value $command_split[2..-1]
        else
            set alias_key "a__$argv[2]"
            set alias_value $argv[3..-1]
        end

        set alias_value (trim_value "$alias_value")

        if set -l abb (contains -i -- "$argv[3..-1]" $__ABBR_TIPS_KEYS)
            set __ABBR_TIPS_KEYS[$abb] $alias_key
            set __ABBR_TIPS_VALUES[$abb] $alias_value
        else
            set -a __ABBR_TIPS_KEYS $alias_key
            set -a __ABBR_TIPS_VALUES $alias_value
        end
    else if test "$command[1]" = functions
        # Parse args as `functions` options
        argparse --name functions e/erase -- $command

        # Update abbreviations list when removing aliases
        if set -q _flag_e
            and set -l abb (contains -i -- a__{$argv[2]} $__ABBR_TIPS_KEYS)
            set -e __ABBR_TIPS_KEYS[$abb]
            set -e __ABBR_TIPS_VALUES[$abb]
        end
    end

    # Exit in the following cases :
    #  - abbreviation has been used
    #  - command is already an abbreviation
    #  - command not found
    #  - or it's a function (alias)
    if test $__abbr_tips_used = 1
        set -g __abbr_tips_used 0
        return
    else if abbr -q "$cmd"
        or not type -q "$command[1]"
        return
    else if string match -q -- "alias $cmd *" (alias)
        return
    else if test (type -t "$command[1]") = function
        and count $ABBR_TIPS_ALIAS_WHITELIST >/dev/null
        and not contains "$command[1]" $ABBR_TIPS_ALIAS_WHITELIST
        return
    end

    set -l abb
    if not set abb (contains -i -- "$cmd" $__ABBR_TIPS_VALUES)
        for r in $ABBR_TIPS_REGEXES
            if set abb (contains -i -- (string replace -r -a -- "$r" '$1' "$cmd") $__ABBR_TIPS_VALUES)
                break
            end
        end
    end

    if test -n "$abb"
        if string match -q "a__*" -- "$__ABBR_TIPS_KEYS[$abb]"
            set -l alias (string sub -s 4 -- "$__ABBR_TIPS_KEYS[$abb]")
            if functions -q "$alias"
                echo -e (string replace -a '{{ .cmd }}' -- "$__ABBR_TIPS_VALUES[$abb]" \
                        (string replace -a '{{ .abbr }}' -- "$alias" "$ABBR_TIPS_PROMPT"))
            else
                set -e __ABBR_TIPS_KEYS[$abb]
                set -e __ABBR_TIPS_VALUES[$abb]
            end
        else
            echo -e (string replace -a '{{ .cmd }}' -- "$__ABBR_TIPS_VALUES[$abb]" \
                    (string replace -a '{{ .abbr }}' -- "$__ABBR_TIPS_KEYS[$abb]" "$ABBR_TIPS_PROMPT"))
        end
    end

    return
end

function __abbr_tips_update --on-event abbr_tips_update
    __abbr_tips_clean
    __abbr_tips_install
end

function __abbr_tips_uninstall --on-event abbr_tips_uninstall
    __abbr_tips_clean
    functions --erase __abbr_tips_init
end
</file>

<file path="dot_config/fish/conf.d/pure.fish">
set --global pure_version 4.12.0 # For bug report and tag-after-merge workflow

# Base colors
_pure_set_default pure_color_primary blue
_pure_set_default pure_color_info cyan
_pure_set_default pure_color_mute brblack
_pure_set_default pure_color_success magenta
_pure_set_default pure_color_normal normal
_pure_set_default pure_color_danger red
_pure_set_default pure_color_light white
_pure_set_default pure_color_warning yellow
_pure_set_default pure_color_dark black

# Prompt
_pure_set_default pure_symbol_prompt "❯"
_pure_set_default pure_symbol_reverse_prompt "❮" # used for VI mode
_pure_set_default pure_color_prompt_on_error pure_color_danger
_pure_set_default pure_color_prompt_on_success pure_color_success

# Current Working Directory
_pure_set_default pure_color_current_directory pure_color_primary
_pure_set_default pure_shorten_prompt_current_directory_length 0
_pure_set_default pure_truncate_prompt_current_directory_keeps -1

# Git
_pure_set_default pure_enable_git true
_pure_set_default pure_symbol_git_unpulled_commits "⇣"
_pure_set_default pure_symbol_git_unpushed_commits "⇡"
_pure_set_default pure_symbol_git_dirty "*"
_pure_set_default pure_symbol_git_stash "≡"
_pure_set_default pure_color_git_unpulled_commits pure_color_info
_pure_set_default pure_color_git_unpushed_commits pure_color_info
_pure_set_default pure_color_git_branch pure_color_mute
_pure_set_default pure_color_git_dirty pure_color_mute
_pure_set_default pure_color_git_stash pure_color_info
_pure_set_default pure_show_numbered_git_indicator false

# Remote info (user@hostname) for SSH and containers (Docker/LXC)
_pure_set_default pure_color_hostname pure_color_mute
_pure_set_default pure_color_at_sign pure_color_mute
_pure_set_default pure_color_username_normal pure_color_mute
_pure_set_default pure_color_username_root pure_color_light

# Number of running jobs
_pure_set_default pure_show_jobs false
_pure_set_default pure_color_jobs pure_color_normal

# Show system time
_pure_set_default pure_show_system_time false
_pure_set_default pure_color_system_time pure_color_mute

# Nix build environment
_pure_set_default pure_enable_nixdevshell false
_pure_set_default pure_symbol_nixdevshell_prefix "❄️" # otherwise nerdfonts: '󱄅' or ''
_pure_set_default pure_color_nixdevshell_prefix pure_color_info
_pure_set_default pure_color_nixdevshell_symbol pure_color_mute

#  env for Python
_pure_set_default pure_enable_virtualenv true
_pure_set_default pure_symbol_virtualenv_prefix "" # 🐍
_pure_set_default pure_color_virtualenv pure_color_mute

# AWS profile name
_pure_set_default pure_enable_aws_profile true
_pure_set_default pure_symbol_aws_profile_prefix "" # ☁️
_pure_set_default pure_color_aws_profile pure_color_warning

# Print current working directory at the beginning of prompt
# true (default):   current directory, git, user@hostname (ssh-only), command duration
# false:            user@hostname (ssh-only), current directory, git, command duration
_pure_set_default pure_begin_prompt_with_current_directory true

# Show exit code of last command as a separate prompt character (cf. https://github.com/sindresorhus/pure/wiki#show-exit-code-of-last-command-as-a-separate-prompt-character)
# false - single prompt character, default
# true - separate prompt character
_pure_set_default pure_separate_prompt_on_error false

# Max execution time of a process before its run time is shown when it exits
_pure_set_default pure_threshold_command_duration 5
_pure_set_default pure_show_subsecond_command_duration false
_pure_set_default pure_color_command_duration pure_color_warning

# VI mode indicator
# true (default):  indicate a non-insert mode by reversing the prompt symbol (❮)
# false:           indicate vi mode with [I], [N], [V]
_pure_set_default pure_reverse_prompt_symbol_in_vimode true

# Title
_pure_set_default pure_symbol_title_bar_separator -
_pure_set_default pure_shorten_window_title_current_directory_length 0
_pure_set_default pure_truncate_window_title_current_directory_keeps -1

# Check for new release on startup
_pure_set_default pure_check_for_new_release false

# Prefix prompt when logged in as root
_pure_set_default pure_show_prefix_root_prompt false
_pure_set_default pure_symbol_prefix_root_prompt "#"
_pure_set_default pure_color_prefix_root_prompt pure_color_danger

# Compact mode
_pure_set_default pure_enable_single_line_prompt false

# Detect when running in container (e.g. docker, podman, LXC/LXD)
_pure_set_default pure_enable_container_detection true
_pure_set_default pure_symbol_container_prefix "" # suggestion: '🐋' or '📦'

# Detect when running in SSH
_pure_set_default pure_symbol_ssh_prefix "" # suggestion: 'ssh:/' or '🔗🔐🔒🌐'

# Display Kubernetes/k8s context and namespace
_pure_set_default pure_enable_k8s false
_pure_set_default pure_symbol_k8s_prefix "☸" # ☸️
_pure_set_default pure_color_k8s_prefix pure_color_info
_pure_set_default pure_color_k8s_context pure_color_success
_pure_set_default pure_color_k8s_namespace pure_color_primary
</file>

<file path="dot_config/fish/conf.d/zoxide.fish">
if status is-interactive

    if type -q zoxide

        # -------------
        # 'zoxide init fish' is very different for different versions of zoxide
        # to guarantee the same behavior we define these functions ourself,
        # especially because the apt package is so old
        # most of these functions were taken from https://github.com/ajeetdsouza/zoxide
        # from version 0.8.1

        if ! builtin functions -q _zoxide_cd
            if builtin functions -q cd
                builtin functions -c cd _zoxide_cd
            else
                alias _zoxide_cd='builtin cd'
            end
        end

        function _zoxide_hook --on-variable PWD
            test -z "$fish_private_mode"
            and command zoxide add -- (builtin pwd -L)
        end

        function z
            set argc (count $argv)
            if test $argc -eq 0
                _zoxide_cd $HOME
            else if test "$argv" = -
                _zoxide_cd -
            else if test -d $argv[-1]
                _zoxide_cd $argv[-1]
            else
                set -l result (command zoxide query $argv)
                and _zoxide_cd $result
            end
        end

        function zi
            set -l result (command zoxide query -i -- $argv)
            and _zoxide_cd $result
        end

        # -------------

        alias cd=z

        # use custom completion
        complete -c z -f # disable files by default 
        complete -c z -x -a '(_zoxide_z_complete)'
    else
        echo "[plugin: zoxide] Command 'zoxide' cannot be found. Not installed or not in path"
    end

end

function _zoxide_uninstall --on-event zoxide_uninstall
    if alias | grep "alias cd z" >/dev/null
        functions -e cd
    end
    if builtin functions -q _zoxide_cd && not functions -q cd
        # restore old cd
        builtin functions -c _zoxide_cd cd
    end
end
</file>

<file path="dot_config/fish/fish_variables">
# This file contains fish universal variable definitions.
# VERSION: 3.0
SETUVAR --export ABBR_TIPS_PROMPT:\x5cn\U0001f4a1\x20\x5ce\x5b1m\x7b\x7b\x20\x2eabbr\x20\x7d\x7d\x5ce\x5b0m\x20\x3d\x3e\x20\x7b\x7b\x20\x2ecmd\x20\x7d\x7d
SETUVAR --export ABBR_TIPS_REGEXES:\x28\x5e\x28\x5cw\x2b\x5cs\x2b\x29\x2b\x28\x2d\x7b1\x2c2\x7d\x29\x5cw\x2b\x29\x28\x5cs\x5cS\x2b\x29\x1e\x28\x5e\x28\x5cs\x3f\x28\x5cw\x2d\x3f\x29\x2b\x29\x7b3\x7d\x29\x2e\x2a\x1e\x28\x5e\x28\x5cs\x3f\x28\x5cw\x2d\x3f\x29\x2b\x29\x7b2\x7d\x29\x2e\x2a\x1e\x28\x5e\x28\x5cs\x3f\x28\x5cw\x2d\x3f\x29\x2b\x29\x7b1\x7d\x29\x2e\x2a
SETUVAR --export __ABBR_TIPS_KEYS:\x1d
SETUVAR --export __ABBR_TIPS_VALUES:\x1d
SETUVAR __fish_initialized:3800
SETUVAR _fisher_acomagu_2F_fish_2D_async_2D_prompt_files:\x7e/\x2econfig/fish/conf\x2ed/__async_prompt\x2efish
SETUVAR _fisher_gazorby_2F_fish_2D_abbreviation_2D_tips_files:\x7e/\x2econfig/fish/functions/__abbr_tips_bind_newline\x2efish\x1e\x7e/\x2econfig/fish/functions/__abbr_tips_bind_space\x2efish\x1e\x7e/\x2econfig/fish/functions/__abbr_tips_clean\x2efish\x1e\x7e/\x2econfig/fish/functions/__abbr_tips_init\x2efish\x1e\x7e/\x2econfig/fish/conf\x2ed/abbr_tips\x2efish
SETUVAR _fisher_icezyclon_2F_zoxide_2E_fish_files:\x7e/\x2econfig/fish/functions/zoxide\x2efish\x1e\x7e/\x2econfig/fish/conf\x2ed/zoxide\x2efish\x1e\x7e/\x2econfig/fish/completions/zoxide\x2efish
SETUVAR _fisher_jorgebucaran_2F_fisher_files:\x7e/\x2econfig/fish/functions/fisher\x2efish\x1e\x7e/\x2econfig/fish/completions/fisher\x2efish
SETUVAR _fisher_plugins:jorgebucaran/fisher\x1eicezyclon/zoxide\x2efish\x1epure\x2dfish/pure\x1eacomagu/fish\x2dasync\x2dprompt\x1egazorby/fish\x2dabbreviation\x2dtips
SETUVAR _fisher_pure_2D_fish_2F_pure_files:\x7e/\x2econfig/fish/functions/_pure_check_availability\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_check_for_new_release\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_detect_container_by_cgroup_method\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_detect_container_by_pid_method\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_format_time\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_get_prompt_symbol\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_is_inside_container\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_is_single_line_prompt\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_k8s_context\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_k8s_namespace\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_parse_directory\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_parse_git_branch\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_place_iterm2_prompt_mark\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prefix_root_prompt\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_print_prompt\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_print_prompt_rows\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_aws_profile\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_beginning\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_command_duration\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_container\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_current_folder\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_ending\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_first_line\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_git\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_git_branch\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_git_dirty\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_git_pending_commits\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_git_stash\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_jobs\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_k8s\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_new_line\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_nixdevshell\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_ssh\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_symbol\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_system_time\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_vimode\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_prompt_virtualenv\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_set_color\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_set_default\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_string_width\x2efish\x1e\x7e/\x2econfig/fish/functions/_pure_user_at_host\x2efish\x1e\x7e/\x2econfig/fish/functions/fish_greeting\x2efish\x1e\x7e/\x2econfig/fish/functions/fish_mode_prompt\x2efish\x1e\x7e/\x2econfig/fish/functions/fish_prompt\x2efish\x1e\x7e/\x2econfig/fish/functions/fish_title\x2efish\x1e\x7e/\x2econfig/fish/conf\x2ed/_pure_init\x2efish\x1e\x7e/\x2econfig/fish/conf\x2ed/pure\x2efish
SETUVAR _fisher_upgraded_to_4_4:\x1d
SETUVAR fish_color_autosuggestion:006363
SETUVAR fish_color_cancel:\x2d\x2dreverse
SETUVAR fish_color_command:009999
SETUVAR fish_color_comment:FF9640
SETUVAR fish_color_cwd:green
SETUVAR fish_color_cwd_root:red
SETUVAR fish_color_end:FFB273
SETUVAR fish_color_error:FF7400
SETUVAR fish_color_escape:00a6b2
SETUVAR fish_color_history_current:\x2d\x2dbold
SETUVAR fish_color_host:normal
SETUVAR fish_color_host_remote:yellow
SETUVAR fish_color_keyword:009999
SETUVAR fish_color_normal:normal
SETUVAR fish_color_operator:00a6b2
SETUVAR fish_color_option:33CCCC
SETUVAR fish_color_param:33CCCC
SETUVAR fish_color_quote:5CCCCC
SETUVAR fish_color_redirection:BF7130
SETUVAR fish_color_search_match:white\x1e\x2d\x2dbold\x1e\x2d\x2dbackground\x3dbrblack
SETUVAR fish_color_selection:white\x1e\x2d\x2dbold\x1e\x2d\x2dbackground\x3dbrblack
SETUVAR fish_color_status:red
SETUVAR fish_color_user:brgreen
SETUVAR fish_color_valid_path:\x2d\x2dunderline\x3dsingle
SETUVAR fish_key_bindings:fish_default_key_bindings
SETUVAR fish_pager_color_background:\x1d
SETUVAR fish_pager_color_completion:normal
SETUVAR fish_pager_color_description:B3A06D
SETUVAR fish_pager_color_prefix:normal\x1e\x2d\x2dbold\x1e\x2d\x2dunderline\x3dsingle
SETUVAR fish_pager_color_progress:brwhite\x1e\x2d\x2dbold\x1e\x2d\x2dbackground\x3dcyan
SETUVAR fish_pager_color_secondary_background:\x1d
SETUVAR fish_pager_color_secondary_completion:\x1d
SETUVAR fish_pager_color_secondary_description:\x1d
SETUVAR fish_pager_color_secondary_prefix:\x1d
SETUVAR fish_pager_color_selected_background:\x2d\x2dbackground\x3dbrblack
SETUVAR fish_pager_color_selected_completion:\x1d
SETUVAR fish_pager_color_selected_description:\x1d
SETUVAR fish_pager_color_selected_prefix:\x1d
SETUVAR fish_user_paths:/home/bondg/\x2efzf/bin
SETUVAR pure_begin_prompt_with_current_directory:true
SETUVAR pure_check_for_new_release:false
SETUVAR pure_color_at_sign:pure_color_mute
SETUVAR pure_color_aws_profile:pure_color_warning
SETUVAR pure_color_command_duration:pure_color_warning
SETUVAR pure_color_current_directory:pure_color_primary
SETUVAR pure_color_danger:red
SETUVAR pure_color_dark:black
SETUVAR pure_color_git_branch:pure_color_mute
SETUVAR pure_color_git_dirty:pure_color_mute
SETUVAR pure_color_git_stash:pure_color_info
SETUVAR pure_color_git_unpulled_commits:pure_color_info
SETUVAR pure_color_git_unpushed_commits:pure_color_info
SETUVAR pure_color_hostname:pure_color_mute
SETUVAR pure_color_info:cyan
SETUVAR pure_color_jobs:pure_color_normal
SETUVAR pure_color_k8s_context:pure_color_success
SETUVAR pure_color_k8s_namespace:pure_color_primary
SETUVAR pure_color_k8s_prefix:pure_color_info
SETUVAR pure_color_light:white
SETUVAR pure_color_mute:brblack
SETUVAR pure_color_nixdevshell_prefix:pure_color_info
SETUVAR pure_color_nixdevshell_symbol:pure_color_mute
SETUVAR pure_color_normal:normal
SETUVAR pure_color_prefix_root_prompt:pure_color_danger
SETUVAR pure_color_primary:blue
SETUVAR pure_color_prompt_on_error:pure_color_danger
SETUVAR pure_color_prompt_on_success:pure_color_success
SETUVAR pure_color_success:magenta
SETUVAR pure_color_system_time:pure_color_mute
SETUVAR pure_color_username_normal:pure_color_mute
SETUVAR pure_color_username_root:pure_color_light
SETUVAR pure_color_virtualenv:pure_color_mute
SETUVAR pure_color_warning:yellow
SETUVAR pure_enable_aws_profile:true
SETUVAR pure_enable_container_detection:true
SETUVAR pure_enable_git:true
SETUVAR pure_enable_k8s:false
SETUVAR pure_enable_nixdevshell:false
SETUVAR pure_enable_single_line_prompt:false
SETUVAR pure_enable_virtualenv:true
SETUVAR pure_reverse_prompt_symbol_in_vimode:true
SETUVAR pure_separate_prompt_on_error:false
SETUVAR pure_shorten_prompt_current_directory_length:0
SETUVAR pure_shorten_window_title_current_directory_length:0
SETUVAR pure_show_jobs:false
SETUVAR pure_show_numbered_git_indicator:false
SETUVAR pure_show_prefix_root_prompt:false
SETUVAR pure_show_subsecond_command_duration:false
SETUVAR pure_show_system_time:false
SETUVAR pure_symbol_aws_profile_prefix:
SETUVAR pure_symbol_container_prefix:
SETUVAR pure_symbol_git_dirty:\x2a
SETUVAR pure_symbol_git_stash:\u2261
SETUVAR pure_symbol_git_unpulled_commits:\u21e3
SETUVAR pure_symbol_git_unpushed_commits:\u21e1
SETUVAR pure_symbol_k8s_prefix:\u2638
SETUVAR pure_symbol_nixdevshell_prefix:\u2744\ufe0f
SETUVAR pure_symbol_prefix_root_prompt:\x23
SETUVAR pure_symbol_prompt:\u276f
SETUVAR pure_symbol_reverse_prompt:\u276e
SETUVAR pure_symbol_ssh_prefix:
SETUVAR pure_symbol_title_bar_separator:\x2d
SETUVAR pure_symbol_virtualenv_prefix:
SETUVAR pure_threshold_command_duration:5
SETUVAR pure_truncate_prompt_current_directory_keeps:\x2d1
SETUVAR pure_truncate_window_title_current_directory_keeps:\x2d1
</file>

<file path="dot_config/fish/functions/__abbr_tips_bind_newline.fish">
function __abbr_tips_bind_newline
    if test $__abbr_tips_used != 1
        if abbr -q -- (string trim -- (commandline))
            set -g __abbr_tips_used 1
        else
            set -g __abbr_tips_used 0
        end
    end
    commandline -f execute
end
</file>

<file path="dot_config/fish/functions/__abbr_tips_bind_space.fish">
function __abbr_tips_bind_space
    commandline -i " "
    if test $__abbr_tips_used != 1
        if abbr -q -- (string trim -- (commandline))
            set -g __abbr_tips_used 1
        else
            set -g __abbr_tips_used 0
        end
    end
    commandline -f expand-abbr
end
</file>

<file path="dot_config/fish/functions/__abbr_tips_clean.fish">
function __abbr_tips_clean -d "Clean plugin variables and functions"
    bind --erase \n
    bind --erase \r
    bind --erase " "
    set --erase __abbr_tips_used
    set --erase __abbr_tips_run_once
    set --erase __ABBR_TIPS_VALUES
    set --erase __ABBR_TIPS_KEYS
    set --erase ABBR_TIPS_PROMPT
    set --erase ABBR_TIPS_AUTO_UPDATE
    set --erase ABBR_TIPS_ALIAS_WHITELIST
    set --erase ABBR_TIPS_REGEXES
    functions --erase __abbr_tips_bind_newline
    functions --erase __abbr_tips_bind_space
    functions --erase __abbr_tips
end
</file>

<file path="dot_config/fish/functions/__abbr_tips_init.fish">
function __abbr_tips_init -d "Initialize abbreviations variables for fish-abbr-tips"
    set -e __ABBR_TIPS_KEYS
    set -e __ABBR_TIPS_VALUES
    set -Ux __ABBR_TIPS_KEYS
    set -Ux __ABBR_TIPS_VALUES

    set -l i 1
    set -l abb (string replace -r '.*-- ' '' -- (abbr -s))
    while test $i -le (count $abb)
        set -l current_abb (string split -m1 -- ' ' "$abb[$i]")
        set -a __ABBR_TIPS_KEYS "$current_abb[1]"
        set -a __ABBR_TIPS_VALUES (string trim -c '\'' -- "$current_abb[2]")
        set i (math $i + 1)
    end

    set -l i 1
    set -l abb (string replace -r '.*-- ' '' -- (alias -s))
    while test $i -le (count $abb)
        set -l current_abb (string split -m2 -- ' ' "$abb[$i]")
        set -a __ABBR_TIPS_KEYS "a__$current_abb[2]"
        set -a __ABBR_TIPS_VALUES (string trim -c '\'' -- "$current_abb[3]")
        set i (math $i + 1)
    end
end
</file>

<file path="dot_config/fish/functions/_pure_check_availability.fish">
function _pure_check_availability \
    --description "Ensure command is available on system" \
    --argument-names \
    feature_flag \
    required_command

    set FAILURE 1

    if not type -q $required_command # command, function or alias are OK
        echo (set_color $pure_color_warning) \
            "$feature_flag feature requires: `$required_command`" \
            (set_color $pure_color_normal)
        return $FAILURE
    end
end
</file>

<file path="dot_config/fish/functions/_pure_check_for_new_release.fish">
function _pure_check_for_new_release \
    --description "Check for new release and show command to install"

    if test "$pure_check_for_new_release" = true
        echo "🛈 Checking for new release…"
        set latest (pure_get_latest_release_version "pure-fish/pure")

        if test "v"$pure_version != $latest
            set --local latest_version (_pure_set_color $pure_color_info)$latest(_pure_set_color $pure_color_normal)
            echo -e "🔔 New version available!\n"
            echo -e (_pure_set_color $pure_color_success)"fisher install pure-fish/pure@$latest_version\n"
        end
    end
end


function pure_get_latest_release_version \
    --argument-names user_repo

    curl \
        --silent \
        "https://api.github.com/repos/$user_repo/releases/latest" \
        | string match --regex '"tag_name": "\K.*?(?=")'
end
</file>

<file path="dot_config/fish/functions/_pure_detect_container_by_cgroup_method.fish">
function _pure_detect_container_by_cgroup_method \
    --description "Linux method to detect container using cgroup. see https://stackoverflow.com/a/37015387/802365" \
    --argument-names cgroup_namespace
    set --query cgroup_namespace[1]; or set cgroup_namespace /proc/1/cgroup

    string match \
        --quiet \
        --entire \
        --regex '(lxc|docker)' <$cgroup_namespace
end
</file>

<file path="dot_config/fish/functions/_pure_detect_container_by_pid_method.fish">
function _pure_detect_container_by_pid_method \
    --description "Linux method to detect container using /proc. see https://stackoverflow.com/a/37015387/802365" \
    --argument-names proc_sched

    set --query proc_sched[1]; or set proc_sched /proc/1/sched

    if test -e $proc_sched
        head -n 1 $proc_sched \
            | string match \
            --quiet \
            --invert \
            --regex 'init|systemd|shepherd'
    end
end
</file>

<file path="dot_config/fish/functions/_pure_format_time.fish">
set SUCCESS 0
set FAILURE 1

function _pure_format_time \
    --description="Format milliseconds to a human readable format" \
    --argument-names \
        milliseconds \
        threshold \
        show_subsecond

    set --query show_subsecond[1]; or set show_subsecond false
    test "$milliseconds" -lt 0; and return $FAILURE
    test "$milliseconds" -lt (math --scale=0 "$threshold * 1000"); and echo; and return $SUCCESS

    set --local time
    set --local days (math --scale=0 "$milliseconds / 86400000")
    test "$days" -gt 0; and set --append time (printf "%sd" $days)
    set --local hours (math --scale=0 "$milliseconds / 3600000 % 24")
    test "$hours" -gt 0; and set --append time (printf "%sh" $hours)
    set --local minutes (math --scale=0 "$milliseconds / 60000 % 60")
    test "$minutes" -gt 0; and set --append time (printf "%sm" $minutes)
    set --local seconds (math --scale=0 "$milliseconds / 1000 % 60")

    if test "$show_subsecond" = true
        set --local threshold_as_ms (math --scale=0 "$threshold*1000")
        set --local subseconds (_pure_format_time_subseconds $milliseconds $threshold_as_ms)
        set --append time $seconds$subseconds's'
    else
        test "$seconds" -gt $threshold; and set --append time (printf "%ss" $seconds)
    end

    echo -e (string join ' ' $time)
end


function _pure_format_time_subseconds \
    --description="Format duration milliseconds to a human readable format" \
    --argument-names \
        duration \
        threshold

    set --local subseconds
    if test "$duration" -gt $threshold
        set --local precision 2
        set --local milliseconds (string sub --start -3 --length $precision $duration)
        set --append subseconds '.'$milliseconds
    end
    echo $subseconds
end
</file>

<file path="dot_config/fish/functions/_pure_get_prompt_symbol.fish">
function _pure_get_prompt_symbol \
    --description 'Print prompt symbol' \
    --argument-names exit_code

    set --local prompt_symbol $pure_symbol_prompt
    test "$pure_reverse_prompt_symbol_in_vimode" = true
    and string match -rq "fish_(vi|hybrid)_key_bindings" $fish_key_bindings
    and not contains "$fish_bind_mode" insert replace
    and set prompt_symbol $pure_symbol_reverse_prompt

    echo "$prompt_symbol"
end
</file>

<file path="dot_config/fish/functions/_pure_is_inside_container.fish">
function _pure_is_inside_container \
    --argument-names cgroup_namespace
    set --query cgroup_namespace[1]; or set cgroup_namespace /proc/1/cgroup

    set --local failure 1
    if set --query pure_enable_container_detection; and test "$pure_enable_container_detection" = true
        set --local success 0
        if test -n "$container"
            return $success
        end

        set --local os_name (uname -s)
        # echo $os_name
        if test "$os_name" = Linux
            if _pure_detect_container_by_cgroup_method $cgroup_namespace
                return $success
            end

            if _pure_detect_container_by_pid_method
                return $success
            end
        end
    end
    return $failure
end
</file>

<file path="dot_config/fish/functions/_pure_is_single_line_prompt.fish">
function _pure_is_single_line_prompt \
    --description 'Test if single line prompt feature is enabled'
    set --query pure_enable_single_line_prompt
    and test "$pure_enable_single_line_prompt" = true
end
</file>

<file path="dot_config/fish/functions/_pure_k8s_context.fish">
function _pure_k8s_context
    kubectl config current-context 2>/dev/null
end
</file>

<file path="dot_config/fish/functions/_pure_k8s_namespace.fish">
function _pure_k8s_namespace
    set namespace (kubectl config view --minify --output 'jsonpath={..namespace}' 2>/dev/null)

    if test -z "$namespace"
        set namespace default
    end

    echo $namespace
end
</file>

<file path="dot_config/fish/functions/_pure_parse_directory.fish">
function _pure_parse_directory \
    --description "Replace '$HOME' with '~'" \
    --argument-names max_path_length

    set --local folder (fish_prompt_pwd_dir_length=$pure_shorten_prompt_current_directory_length prompt_pwd)

    if test -n "$max_path_length"
        if test (string length $folder) -gt $max_path_length
            # If path exceeds maximum symbol limit, force fish path formating function to use 1 character
            set folder (fish_prompt_pwd_dir_length=1 prompt_pwd)
        end
    end

    if test "$pure_truncate_prompt_current_directory_keeps" -ge 1
        set folder (
            string split '/' $folder \
                | tail -n $pure_truncate_prompt_current_directory_keeps \
                | string join '/'
        )
    end

    echo $folder
end
</file>

<file path="dot_config/fish/functions/_pure_parse_git_branch.fish">
function _pure_parse_git_branch --description "Parse current Git branch name"
    command git symbolic-ref --short HEAD 2>/dev/null;
        or command git name-rev --name-only HEAD 2>/dev/null
end
</file>

<file path="dot_config/fish/functions/_pure_place_iterm2_prompt_mark.fish">
function _pure_place_iterm2_prompt_mark
    if functions -q iterm2_prompt_mark
        iterm2_prompt_mark
    end
end
</file>

<file path="dot_config/fish/functions/_pure_prefix_root_prompt.fish">
function _pure_prefix_root_prompt
    set --local username (id -u -n) # current user name
    set --local prefix_root_prompt

    if set --query pure_show_prefix_root_prompt; and test "$pure_show_prefix_root_prompt" = true -a "$username" = "root"
        set --local prefix_color (_pure_set_color $pure_color_prefix_root_prompt)
        set prefix_root_prompt "$prefix_color$pure_symbol_prefix_root_prompt"
    end

    echo "$prefix_root_prompt"
end
</file>

<file path="dot_config/fish/functions/_pure_print_prompt_rows.fish">
function _pure_print_prompt_rows \
    --description "Manage default vs. compact prompt"

    # print current path, git branch/status, command duration
    if _pure_is_single_line_prompt
        echo -e -n (_pure_prompt_first_line)
    else
        echo -e (_pure_prompt_first_line)
    end
end
</file>

<file path="dot_config/fish/functions/_pure_print_prompt.fish">
function _pure_print_prompt \
    --description 'Concatenate parts single prompt string'
    set --local prompt

    for prompt_part in $argv
        if test (_pure_string_width $prompt_part) -gt 0
            set --append prompt "$prompt_part"
        end
    end

    echo (string trim -l $prompt)
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_aws_profile.fish">
function _pure_prompt_aws_profile --description "Display AWS profile name"

    if set --query pure_enable_aws_profile;
        and test "$pure_enable_aws_profile" = true

        set --local aws_profile ''
        set --local aws_profile_color (_pure_set_color $pure_color_aws_profile)

        if test -n "$AWS_VAULT"
            set aws_profile "$AWS_VAULT"
        else if test -n "$AWS_PROFILE" -o "$AWS_PROFILE" != default
            set aws_profile "$AWS_PROFILE"
        end

        if test -n $aws_profile
            echo "$pure_symbol_aws_profile_prefix$aws_profile_color$aws_profile"
        end
    end
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_beginning.fish">
function _pure_prompt_beginning \
    --description 'Clear existing line content'

    set --local clear_line "\r\033[K"

    echo $clear_line
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_command_duration.fish">
function _pure_prompt_command_duration
    set --local command_duration

    # Get command execution duration
    if test -n "$CMD_DURATION"
        set command_duration (_pure_format_time $CMD_DURATION $pure_threshold_command_duration $pure_show_subsecond_command_duration)
    end
    set --local command_duration_color (_pure_set_color $pure_color_command_duration)

    echo "$command_duration_color$command_duration"
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_container.fish">
function _pure_prompt_container
    if _pure_is_inside_container
        echo "$pure_symbol_container_prefix"(_pure_user_at_host)
    end
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_current_folder.fish">
set FAILURE 1

function _pure_prompt_current_folder --argument-names current_prompt_width

    if test -z "$current_prompt_width"; return $FAILURE; end

    set --local current_folder (_pure_parse_directory (math $COLUMNS - $current_prompt_width - 1))
    set --local current_folder_color (_pure_set_color $pure_color_current_directory)

    echo "$current_folder_color$current_folder"
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_ending.fish">
function _pure_prompt_ending
    echo (set_color normal)" "
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_first_line.fish">
set --global FAILURE 1

function _pure_prompt_first_line \
    --description 'Print contextual information before prompt.'

    set --local prompt_ssh (_pure_prompt_ssh)
    set --local prompt_container (_pure_prompt_container)
    set --local prompt_k8s (_pure_prompt_k8s)
    set --local prompt_git (_pure_prompt_git)
    set --local prompt_command_duration (_pure_prompt_command_duration)
    set --local prompt (_pure_print_prompt \
                            $prompt_ssh \
                            $prompt_container \
                            $prompt_k8s \
                            $prompt_git \
                            $prompt_command_duration
                        )
    set --local prompt_width (_pure_string_width $prompt)
    set --local current_folder (_pure_prompt_current_folder $prompt_width)

    set --local prompt_components
    if set --query pure_begin_prompt_with_current_directory; and test "$pure_begin_prompt_with_current_directory" = true
        set prompt_components \
            $current_folder \
            $prompt_git \
            $prompt_ssh \
            $prompt_container \
            $prompt_k8s \
            $prompt_command_duration
    else
        set prompt_components \
            $prompt_ssh \
            $prompt_container \
            $prompt_k8s \
            $current_folder \
            $prompt_git \
            $prompt_command_duration
    end

    echo (_pure_print_prompt $prompt_components)
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_git_branch.fish">
function _pure_prompt_git_branch
    set --local git_branch (_pure_parse_git_branch) # current git branch
    set --local git_branch_color (_pure_set_color $pure_color_git_branch)

    echo "$git_branch_color$git_branch"
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_git_dirty.fish">
function _pure_prompt_git_dirty
    set --local git_dirty_symbol
    set --local git_dirty_color

    set --local is_git_dirty (
        # HEAD may not exist (e.g. immediately after git init); diff-index is
        # fast for staged checks but requires a ref.
        #
        # The diff-index (or diff --staged) checks for staged changes; the diff
        # checks for unstaged changes; the ls-files checks for untracked files.
        # We put them in this order because checking staged changes is *fast*.
        if command git rev-list --max-count=1 HEAD -- >/dev/null 2>&1;
            not command git diff-index --ignore-submodules --cached --quiet HEAD -- >/dev/null 2>&1;
        else;
            not command git diff --staged --ignore-submodules --no-ext-diff --quiet --exit-code >/dev/null 2>&1;
        end
        or not command git diff --ignore-submodules --no-ext-diff --quiet --exit-code >/dev/null 2>&1
        or command git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' >/dev/null 2>&1
        and echo "true"
    )
    if test -n "$is_git_dirty"  # untracked or un-commited files
        set git_dirty_symbol "$pure_symbol_git_dirty"
        set git_dirty_color (_pure_set_color $pure_color_git_dirty)
    end

    echo "$git_dirty_color$git_dirty_symbol"
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_git_pending_commits.fish">
function _pure_prompt_git_pending_commits
    set --local git_unpushed_commits
    set --local git_unpulled_commits

    set --local has_upstream (command git rev-parse --abbrev-ref '@{upstream}' 2>/dev/null)
    if test -n "$has_upstream"  # check there is an upstream repo configured
        and test "$has_upstream" != '@{upstream}' # Fixed #179, dont check the empty repo
        command git rev-list --left-right --count 'HEAD...@{upstream}' \
        | read --local --array git_status
        set --local commit_to_push $git_status[1]
        set --local commit_to_pull $git_status[2]

        if test "$commit_to_push" -gt 0  # upstream is behind local repo
            set --local git_unpushed_commits_color \
                (_pure_set_color $pure_color_git_unpushed_commits)
            set git_unpushed_commits "$git_unpushed_commits_color$pure_symbol_git_unpushed_commits"
            if test "$pure_show_numbered_git_indicator" = true
                set git_unpushed_commits "$git_unpushed_commits$commit_to_push"
            end
        end

        if test "$commit_to_pull" -gt 0  # upstream is ahead of local repo
            set --local git_unpulled_commits_color \
                (_pure_set_color $pure_color_git_unpulled_commits)
            set git_unpulled_commits "$git_unpulled_commits_color$pure_symbol_git_unpulled_commits"
            if test "$pure_show_numbered_git_indicator" = true
                set git_unpulled_commits "$git_unpulled_commits$commit_to_pull"
            end
        end
    end

    echo "$git_unpushed_commits$git_unpulled_commits"
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_git_stash.fish">
function _pure_prompt_git_stash
    set --local git_stash_symbol
    set --local git_stash_color
    set --local git_stash_number

    set --local git_stash_count (
        command git rev-list --walk-reflogs --count refs/stash 2> /dev/null
        or echo "0"
    )
    if test "$git_stash_count" -gt 0 # has git stash
        set git_stash_symbol " $pure_symbol_git_stash"
        set git_stash_color (_pure_set_color $pure_color_git_stash)
        if test "$pure_show_numbered_git_indicator" = true
            set git_stash_number "$git_stash_count"
        end
    end

    echo "$git_stash_color$git_stash_symbol$git_stash_number"
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_git.fish">
function _pure_prompt_git \
    --description 'Print git repository informations: branch name, dirty, upstream ahead/behind'

    set ABORT_FEATURE 2

    if set --query pure_enable_git; and test "$pure_enable_git" != true
        return
    end

    if not type -q --no-functions git  # skip git-related features when `git` is not available
        return $ABORT_FEATURE
    end

    set --local is_git_repository (command git rev-parse --is-inside-work-tree 2>/dev/null)

    if test -n "$is_git_repository"
        set --local git_prompt (_pure_prompt_git_branch)(_pure_prompt_git_dirty)(_pure_prompt_git_stash)
        set --local git_pending_commits (_pure_prompt_git_pending_commits)

        if test (_pure_string_width $git_pending_commits) -ne 0
            set --append git_prompt $git_pending_commits
        end

        echo $git_prompt
    end
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_jobs.fish">
function _pure_prompt_jobs --description "Display number of running jobs"
    if set --query pure_show_jobs; and test "$pure_show_jobs" = true
        set --local njobs (count (jobs -p))
        set --local jobs_color (_pure_set_color $pure_color_jobs)
        if test "$njobs" -gt 0
            echo "$jobs_color"[$njobs]
        end
    end
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_k8s.fish">
function _pure_prompt_k8s
    if set --query pure_enable_k8s;
        and test "$pure_enable_k8s" = true;
        and _pure_check_availability pure_enable_k8s kubectl
        and test -n (_pure_k8s_context) # todo: use $(cmd) syntax when Fish 3.3.1 is dropped

        set --local context (_pure_set_color $pure_color_k8s_context)(_pure_k8s_context)

        if test -n "$context"
            set --local symbol (_pure_set_color $pure_color_k8s_prefix)$pure_symbol_k8s_prefix
            set --local namespace (_pure_set_color $pure_color_k8s_namespace)(_pure_k8s_namespace)

            echo "$symbol $context/$namespace"
        end
    end
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_new_line.fish">
function _pure_prompt_new_line \
    --description "Do not add a line break to a brand new session" \
    --on-event fish_prompt

    set --local new_line ''
    if not _pure_is_single_line_prompt; and test "$_pure_fresh_session" = false
        set new_line "\n"
    end

    echo -e -n (_pure_prompt_beginning)"$new_line"
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_nixdevshell.fish">
function _pure_prompt_nixdevshell \
    --description "Indicate if nix develop shell is activated"

    if set --query pure_enable_nixdevshell;
        and test "$pure_enable_nixdevshell" = true;
        and test -n "$IN_NIX_SHELL"

        set --local prefix (_pure_set_color $pure_color_nixdevshell_prefix)$pure_symbol_nixdevshell_prefix
        set --local symbol (_pure_set_color $pure_color_nixdevshell_status)$IN_NIX_SHELL

        echo "$prefix$symbol"
    end
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_ssh.fish">
function _pure_prompt_ssh
    if test "$SSH_CONNECTION" != ""
        echo "$pure_symbol_ssh_prefix"(_pure_user_at_host)
    end
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_symbol.fish">
function _pure_prompt_symbol \
    --description 'Print prompt symbol' \
    --argument-names exit_code

    set --local prompt_symbol (_pure_get_prompt_symbol)
    set --local symbol_color_success (_pure_set_color $pure_color_prompt_on_success)
    set --local symbol_color_error (_pure_set_color $pure_color_prompt_on_error)
    set --local command_succeed 0

    set --local symbol_color $symbol_color_success # default pure symbol color
    if set --query exit_code; and test "$exit_code" -ne $command_succeed
        set symbol_color $symbol_color_error # different pure symbol color when previous command failed

        if set --query pure_separate_prompt_on_error; and test "$pure_separate_prompt_on_error" = true
            set symbol_color "$symbol_color_error$prompt_symbol$symbol_color_success"
        end
    end

    echo "$symbol_color$prompt_symbol"
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_system_time.fish">
function _pure_prompt_system_time --description "Display system time"
    if set --query pure_show_system_time; and test "$pure_show_system_time" = true
        set --local time_color (_pure_set_color $pure_color_system_time)
        echo "$time_color"(date '+%T')
    end
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_vimode.fish">
function _pure_prompt_vimode
    if set --query pure_reverse_prompt_symbol_in_vimode;
        and test "$pure_reverse_prompt_symbol_in_vimode" = false
        echo (fish_default_mode_prompt)
    end
end
</file>

<file path="dot_config/fish/functions/_pure_prompt_virtualenv.fish">
function _pure_prompt_virtualenv --description "Display virtualenv directory"

    if set --query pure_enable_virtualenv;
        and test "$pure_enable_virtualenv" = true

        set --local virtualenv ''
        set --local virtualenv_color (_pure_set_color $pure_color_virtualenv)
        if test -n "$VIRTUAL_ENV"
            set virtualenv (basename "$VIRTUAL_ENV")
        else if test -n "$CONDA_DEFAULT_ENV"
            set virtualenv (basename "$CONDA_DEFAULT_ENV")
        end

        if test -n $virtualenv
            echo "$pure_symbol_virtualenv_prefix$virtualenv_color$virtualenv"
        end
    end
end
</file>

<file path="dot_config/fish/functions/_pure_prompt.fish">
function _pure_prompt \
    --description 'Print prompt symbol' \
    --argument-names exit_code

    set --local jobs (_pure_prompt_jobs)
    set --local nixdevshell (_pure_prompt_nixdevshell) # Nix build environment indicator
    set --local virtualenv (_pure_prompt_virtualenv) # Python virtualenv name
    set --local aws_profile (_pure_prompt_aws_profile) # AWS profile name
    set --local vimode_indicator (_pure_prompt_vimode) # vi-mode indicator
    set --local pure_symbol (_pure_prompt_symbol $exit_code)
    set --local system_time (_pure_prompt_system_time)
    set --local root_prefix (_pure_prefix_root_prompt)
    set --local space

    if _pure_is_single_line_prompt
        set space ' '
    end

    echo (\
        _pure_print_prompt \
        $space \
        $system_time \
        $root_prefix \
        $jobs \
        $nixdevshell \
        $virtualenv \
        $aws_profile \
        $vimode_indicator \
        $pure_symbol \
    )
end
</file>

<file path="dot_config/fish/functions/_pure_set_color.fish">
function _pure_set_color \
    --description 'Set color' \
    --argument-names var

    set --local color $var
    # Backwards compatibility for colors defined as control sequencies instead of fish colors
    if not string match --quiet --all --regex '\e\[[^m]*m' $color[1]
        and set -q $color
            set color $$var
    end

    set --local result $color
    if not string match --quiet --all --regex '\e\[[^m]*m' $result[1]
        and not test -z $result[1]
            set result (set_color $color)
    end

    echo "$result"
end
</file>

<file path="dot_config/fish/functions/_pure_set_default.fish">
function _pure_set_default \
    --description 'Set default value for configuration variable' \
    --argument-names var default

    set is_available_universally (not set --query --universal $var; or test -z $$var; echo $status)
    set is_available_globally (not set --query --global $var; or test -z $$var; echo $status)

    if test "$is_available_universally" -eq 0 -a $is_available_globally -eq 0
        set --universal $var "$default"
    end
end
</file>

<file path="dot_config/fish/functions/_pure_string_width.fish">
function _pure_string_width \
    --description 'returns raw string length, i.e. ignore ANSI-color' \
    --argument-names prompt

    set --local empty ''
    set --local raw_prompt (string replace --all --regex '\e\[[^m]*m' $empty -- $prompt)

    string length -- $raw_prompt
end
</file>

<file path="dot_config/fish/functions/_pure_user_at_host.fish">
function _pure_user_at_host
    set --local username (id -u -n) # current user name
    set --local at_sign "@"
    set --local at_sign_color (_pure_set_color $pure_color_at_sign)
    set --local hostname_color (_pure_set_color $pure_color_hostname)

    set --local username_color (_pure_set_color $pure_color_username_normal) # default color
    if test "$username" = root
        set username_color (_pure_set_color $pure_color_username_root) # different color for root
    end

    echo "$username_color$username$at_sign_color$at_sign$hostname_color$hostname"
end
</file>

<file path="dot_config/fish/functions/fish_mode_prompt.fish">
function fish_mode_prompt
end
</file>

<file path="dot_config/fish/functions/fish_prompt.fish">
function fish_prompt --description 'Write out the prompt'
        set -l last_status $status
    
        prompt_login
    
        echo -n ':'
    
        # PWD
        set_color $fish_color_cwd
        echo -n (prompt_pwd)
        set_color normal
    
        set -q __fish_git_prompt_showdirtystate
        or set -g __fish_git_prompt_showdirtystate 1
        set -q __fish_git_prompt_showuntrackedfiles
        or set -g __fish_git_prompt_showuntrackedfiles 1
        set -q __fish_git_prompt_showcolorhints
        or set -g __fish_git_prompt_showcolorhints 1
        set -q __fish_git_prompt_color_untrackedfiles
        or set -g __fish_git_prompt_color_untrackedfiles yellow
        set -q __fish_git_prompt_char_untrackedfiles
        or set -g __fish_git_prompt_char_untrackedfiles '?'
        set -q __fish_git_prompt_color_invalidstate
        or set -g __fish_git_prompt_color_invalidstate red
        set -q __fish_git_prompt_char_invalidstate
        or set -g __fish_git_prompt_char_invalidstate '!'
        set -q __fish_git_prompt_color_dirtystate
        or set -g __fish_git_prompt_color_dirtystate blue
        set -q __fish_git_prompt_char_dirtystate
        or set -g __fish_git_prompt_char_dirtystate '*'
        set -q __fish_git_prompt_char_stagedstate
        or set -g __fish_git_prompt_char_stagedstate '✚'
        set -q __fish_git_prompt_color_cleanstate
        or set -g __fish_git_prompt_color_cleanstate green
        set -q __fish_git_prompt_char_cleanstate
        or set -g __fish_git_prompt_char_cleanstate '✓'
        set -q __fish_git_prompt_color_stagedstate
        or set -g __fish_git_prompt_color_stagedstate yellow
        set -q __fish_git_prompt_color_branch_dirty
        or set -g __fish_git_prompt_color_branch_dirty red
        set -q __fish_git_prompt_color_branch_staged
        or set -g __fish_git_prompt_color_branch_staged yellow
        set -q __fish_git_prompt_color_branch
        or set -g __fish_git_prompt_color_branch green
        set -q __fish_git_prompt_char_stateseparator
        or set -g __fish_git_prompt_char_stateseparator '⚡'
        fish_vcs_prompt '|%s'
        echo
    
        if not test $last_status -eq 0
                set_color $fish_color_error
        end
    
        echo -n '➤ '
        set_color normal
end
</file>

<file path="dot_config/fish/functions/fish_title.fish">
function fish_title \
    --description "Set title to current folder and shell name" \
    --argument-names last_command

    set --local current_folder (fish_prompt_pwd_dir_length=$pure_shorten_window_title_current_directory_length prompt_pwd)
    set --local current_command (status current-command 2>/dev/null; or echo $_)[1] # we use index to ignore extraneous item, see #360

    set --local prompt "$current_folder: $last_command $pure_symbol_title_bar_separator $current_command"

    if test -z "$last_command"
        set prompt "$current_folder $pure_symbol_title_bar_separator $current_command"
    end

    echo $prompt
end
</file>

<file path="dot_config/fish/functions/fish_user_key_bindings.fish">
function fish_user_key_bindings
  fzf --fish | source
end
</file>

<file path="dot_config/fish/functions/fisher.fish">
function fisher --argument-names cmd --description "A plugin manager for Fish"
    set --query fisher_path || set --local fisher_path $__fish_config_dir
    set --local fisher_version 4.4.5
    set --local fish_plugins $__fish_config_dir/fish_plugins

    switch "$cmd"
        case -v --version
            echo "fisher, version $fisher_version"
        case "" -h --help
            echo "Usage: fisher install <plugins...>  Install plugins"
            echo "       fisher remove  <plugins...>  Remove installed plugins"
            echo "       fisher update  <plugins...>  Update installed plugins"
            echo "       fisher update                Update all installed plugins"
            echo "       fisher list    [<regex>]     List installed plugins matching regex"
            echo "Options:"
            echo "       -v, --version  Print version"
            echo "       -h, --help     Print this help message"
            echo "Variables:"
            echo "       \$fisher_path  Plugin installation path. Default: $__fish_config_dir" | string replace --regex -- $HOME \~
        case ls list
            string match --entire --regex -- "$argv[2]" $_fisher_plugins
        case install update remove
            isatty || read --local --null --array stdin && set --append argv $stdin

            set --local install_plugins
            set --local update_plugins
            set --local remove_plugins
            set --local arg_plugins $argv[2..-1]
            set --local old_plugins $_fisher_plugins
            set --local new_plugins

            test -e $fish_plugins && set --local file_plugins (string match --regex -- '^[^\s]+$' <$fish_plugins | string replace -- \~ ~)

            if ! set --query argv[2]
                if test "$cmd" != update
                    echo "fisher: Not enough arguments for command: \"$cmd\"" >&2 && return 1
                else if ! set --query file_plugins
                    echo "fisher: \"$fish_plugins\" file not found: \"$cmd\"" >&2 && return 1
                end
                set arg_plugins $file_plugins
            end

            for plugin in $arg_plugins
                set plugin (test -e "$plugin" && realpath $plugin || string lower -- $plugin)
                contains -- "$plugin" $new_plugins || set --append new_plugins $plugin
            end

            if set --query argv[2]
                for plugin in $new_plugins
                    if contains -- "$plugin" $old_plugins
                        test "$cmd" = remove &&
                            set --append remove_plugins $plugin ||
                            set --append update_plugins $plugin
                    else if test "$cmd" = install
                        set --append install_plugins $plugin
                    else
                        echo "fisher: Plugin not installed: \"$plugin\"" >&2 && return 1
                    end
                end
            else
                for plugin in $new_plugins
                    contains -- "$plugin" $old_plugins &&
                        set --append update_plugins $plugin ||
                        set --append install_plugins $plugin
                end

                for plugin in $old_plugins
                    contains -- "$plugin" $new_plugins || set --append remove_plugins $plugin
                end
            end

            set --local pid_list
            set --local source_plugins
            set --local fetch_plugins $update_plugins $install_plugins
            set --local fish_path (status fish-path)

            echo (set_color --bold)fisher $cmd version $fisher_version(set_color normal)

            for plugin in $fetch_plugins
                set --local source (command mktemp -d)
                set --append source_plugins $source

                command mkdir -p $source/{completions,conf.d,themes,functions}

                $fish_path --command "
                    if test -e $plugin
                        command cp -Rf $plugin/* $source
                    else
                        set temp (command mktemp -d)
                        set repo (string split -- \@ $plugin) || set repo[2] HEAD

                        if set path (string replace --regex -- '^(https://)?gitlab.com/' '' \$repo[1])
                            set name (string split -- / \$path)[-1]
                            set url https://gitlab.com/\$path/-/archive/\$repo[2]/\$name-\$repo[2].tar.gz
                        else
                            set url https://api.github.com/repos/\$repo[1]/tarball/\$repo[2]
                        end

                        echo Fetching (set_color --underline)\$url(set_color normal)

                        if command curl -q --silent -L \$url | command tar -xzC \$temp -f - 2>/dev/null
                            command cp -Rf \$temp/*/* $source
                        else
                            echo fisher: Invalid plugin name or host unavailable: \\\"$plugin\\\" >&2
                            command rm -rf $source
                        end

                        command rm -rf \$temp
                    end

                    set files $source/* && string match --quiet --regex -- .+\.fish\\\$ \$files
                " &

                set --append pid_list (jobs --last --pid)
            end

            wait $pid_list 2>/dev/null

            for plugin in $fetch_plugins
                if set --local source $source_plugins[(contains --index -- "$plugin" $fetch_plugins)] && test ! -e $source
                    if set --local index (contains --index -- "$plugin" $install_plugins)
                        set --erase install_plugins[$index]
                    else
                        set --erase update_plugins[(contains --index -- "$plugin" $update_plugins)]
                    end
                end
            end

            for plugin in $update_plugins $remove_plugins
                if set --local index (contains --index -- "$plugin" $_fisher_plugins)
                    set --local plugin_files_var _fisher_(string escape --style=var -- $plugin)_files

                    if contains -- "$plugin" $remove_plugins
                        for name in (string replace --filter --regex -- '.+/conf\.d/([^/]+)\.fish$' '$1' $$plugin_files_var)
                            emit {$name}_uninstall
                        end
                        printf "%s\n" Removing\ (set_color red --bold)$plugin(set_color normal) "         "$$plugin_files_var | string replace -- \~ ~
                        set --erase _fisher_plugins[$index]
                    end

                    command rm -rf (string replace -- \~ ~ $$plugin_files_var)

                    functions --erase (string replace --filter --regex -- '.+/functions/([^/]+)\.fish$' '$1' $$plugin_files_var)

                    for name in (string replace --filter --regex -- '.+/completions/([^/]+)\.fish$' '$1' $$plugin_files_var)
                        complete --erase --command $name
                    end

                    set --erase $plugin_files_var
                end
            end

            if set --query update_plugins[1] || set --query install_plugins[1]
                command mkdir -p $fisher_path/{functions,themes,conf.d,completions}
            end

            for plugin in $update_plugins $install_plugins
                set --local source $source_plugins[(contains --index -- "$plugin" $fetch_plugins)]
                set --local files $source/{functions,themes,conf.d,completions}/*

                if set --local index (contains --index -- $plugin $install_plugins)
                    set --local user_files $fisher_path/{functions,themes,conf.d,completions}/*
                    set --local conflict_files

                    for file in (string replace -- $source/ $fisher_path/ $files)
                        contains -- $file $user_files && set --append conflict_files $file
                    end

                    if set --query conflict_files[1] && set --erase install_plugins[$index]
                        echo -s "fisher: Cannot install \"$plugin\": please remove or move conflicting files first:" \n"        "$conflict_files >&2
                        continue
                    end
                end

                for file in (string replace -- $source/ "" $files)
                    command cp -RLf $source/$file $fisher_path/$file
                end

                set --local plugin_files_var _fisher_(string escape --style=var -- $plugin)_files

                set --query files[1] && set --universal $plugin_files_var (string replace -- $source $fisher_path $files | string replace -- ~ \~)

                contains -- $plugin $_fisher_plugins || set --universal --append _fisher_plugins $plugin
                contains -- $plugin $install_plugins && set --local event install || set --local event update

                printf "%s\n" Installing\ (set_color --bold)$plugin(set_color normal) "           "$$plugin_files_var | string replace -- \~ ~

                for file in (string match --regex -- '.+/[^/]+\.fish$' $$plugin_files_var | string replace -- \~ ~)
                    source $file
                    if set --local name (string replace --regex -- '.+conf\.d/([^/]+)\.fish$' '$1' $file)
                        emit {$name}_$event
                    end
                end
            end

            command rm -rf $source_plugins

            if set --query _fisher_plugins[1]
                set --local commit_plugins

                for plugin in $file_plugins
                    contains -- (string lower -- $plugin) (string lower -- $_fisher_plugins) && set --append commit_plugins $plugin
                end

                for plugin in $_fisher_plugins
                    contains -- (string lower -- $plugin) (string lower -- $commit_plugins) || set --append commit_plugins $plugin
                end

                string replace --regex -- $HOME \~ $commit_plugins >$fish_plugins
            else
                set --erase _fisher_plugins
                command rm -f $fish_plugins
            end

            set --local total (count $install_plugins) (count $update_plugins) (count $remove_plugins)

            test "$total" != "0 0 0" && echo (string join ", " (
                test $total[1] = 0 || echo "Installed $total[1]") (
                test $total[2] = 0 || echo "Updated $total[2]") (
                test $total[3] = 0 || echo "Removed $total[3]")
            ) plugin/s
        case \*
            echo "fisher: Unknown command: \"$cmd\"" >&2 && return 1
    end
end

if ! set --query _fisher_upgraded_to_4_4
    set --universal _fisher_upgraded_to_4_4
    if functions --query _fisher_list
        set --query XDG_DATA_HOME[1] || set --local XDG_DATA_HOME ~/.local/share
        command rm -rf $XDG_DATA_HOME/fisher
        functions --erase _fisher_{list,plugin_parse}
        fisher update >/dev/null 2>/dev/null
    else
        for var in (set --names | string match --entire --regex '^_fisher_.+_files$')
            set $var (string replace -- ~ \~ $$var)
        end
        functions --erase _fisher_fish_postexec
    end
end
</file>

<file path="dot_config/fish/functions/zoxide.fish">
function _zoxide_z_complete -d "Complete directory first or zoxide queries otherwise" --argument-names comp desc
    # most of this functions is compied from __fish_complete_directories with a small tweak

    # comp is the currently completing token
    if not set -q comp[1]
        set comp (commandline -ct)
    end
    # cmd are all tokens including the current one except the command
    set -l cmd (commandline -opc) $comp
    set -e cmd[1]

    if test "$comp" = "$cmd"
        # if we are on our first token, then allow file complete
        # otherwise use zoxide (for multi word zoxide query)

        # HACK: We call into the file completions by using a non-existent command.
        # If we used e.g. `ls`, we'd run the risk of completing its options or another kind of argument.
        # But since we default to file completions, if something doesn't have another completion...
        set -f dirs (complete -C"nonexistentcommandooheehoohaahaahdingdongwallawallabingbang $comp" | string match -r '.*/$')
    end

    # in the future: replace entire cmd with tab complete instead of only last token
    # at the moment: is handled in z function to always enter last token if directory

    if set -q dirs[1]
        # if we find any files to complete use those
        printf "%s\t$desc\n" $dirs
    else
        # otherwise use zoxide
        zoxide query -l $cmd
    end
end

function _zoxide_equals_first_token -a check -d "Test if first non-switch token equals given one"
    set -l tokens (commandline -co)
    set -e tokens[1]
    set -l tokens (string replace -r --filter '^([^-].*)' '$1' -- $tokens)
    if set -q tokens[1]
        test $tokens[1] = $check
    else
        return 1
    end
end
</file>

<file path="dot_config/opencode/opencode.json">
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "openrouter": {
      "models": {},
      "options": {
        "apiKey": "{env:OPENROUTER_API_KEY}"
      }
    },
    "zai": {
      "models": {},
      "options": {
        "apiKey": "{env:ZAI_API_KEY}"
      }
    }
  }
}
</file>

<file path="dot_config/starship.toml">
add_newline = true
command_timeout = 200
format = "[$directory$git_branch$git_status]($style)$character"

[character]
error_symbol = "[✗](bold cyan)"
success_symbol = "[❯](bold cyan)"

[directory]
truncation_length = 2
truncation_symbol = "…/"
repo_root_style = "bold cyan"
repo_root_format = "[$repo_root]($repo_root_style)[$path]($style)[$read_only]($read_only_style) "

[git_branch]
format = "[$branch]($style) "
style = "italic cyan"

[git_status]
format     = '[$all_status]($style)'
style      = "cyan"
ahead      = "⇡${count} "
diverged   = "⇕⇡${ahead_count}⇣${behind_count} "
behind     = "⇣${count} "
conflicted = " "
up_to_date = " "
untracked  = "? "
modified   = " "
stashed    = ""
staged     = ""
renamed    = ""
deleted    = ""
</file>

<file path="dot_config/zsh/aliases.zsh">
# Zsh aliases managed by chezmoi
# Place at ~/.local/share/chezmoi/dot_config/zsh/aliases.zsh

# File and directory operations
alias mkdir="mkdir -p"
alias cp="cp -i"
alias mv="mv -i"
alias rm="rm -i"
alias du="du -h"
alias df="df -h"
alias cat="bat"
alias grep="rg"
alias z="zoxide"

# Development
alias vim="nvim"
alias vi="nvim"
alias v="nvim"
alias python="python3"
alias py="python3"
alias pip="pip3"

# Network and system
alias ping="ping -c 5"
alias myip="curl -s https://api.ipify.org"
alias ports="netstat -tulan"
alias ps="ps aux"
alias psg="ps aux | grep"
alias kill="kill -9"

# Package management
alias brew-update="brew update && brew upgrade && brew cleanup"
alias npm-update="npm update -g"

# Directory navigation
alias config="cd ~/.config"

# Utility aliases
alias c="clear"
alias h="history"
alias path="echo $PATH | tr ':' '\n'"
alias fzf-preview="fzf --preview 'bat --color=always {}'"
alias please="sudo !!"
alias reload="exec zsh"

# Tmux aliases (if using tmux)
alias t="tmux"
alias ta="tmux attach"
alias tl="tmux list-sessions"
alias tn="tmux new-session"
alias tk="tmux kill-session"
alias ts="tmux switch-client"
alias tkill="tmux kill-server"

# Git aliases (enhanced)
alias glog="git log --oneline --graph --decorate --all"
alias gst="git status"
alias gco="git checkout"
alias gbr="git branch"
alias gadd="git add ."
alias gcm="git commit -m"
alias gp="git push"
alias gl="git pull"
alias gpl="git pull --rebase"
alias gpp="git pull --rebase && git push"
alias gd="git diff"
alias gds="git diff --stat"
alias gdc="git diff --cached"
alias grs="git restore"
alias grst="git restore --staged"
alias greset="git reset"
alias gclean="git clean -fd"
alias gsync="git fetch --all --prune && git pull --rebase"

# Lazygit alias
alias lg="lazygit"
</file>

<file path="dot_shortcuts/ssh.sh">
ssh wslarch
</file>

<file path="dot_ssh/config">
Host wslarch
    HostName 192.168.178.88
    User bondg
    IdentityFile ~/.ssh/id_ed25519
    Port 4444
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

This is a personal dotfiles repository managed with [Chezmoi](https://www.chezmoi.io/), a dotfile management system that handles configuration across multiple machines while supporting templating and secrets management.

## Installation & Setup

### Initial Setup
```bash
# Install and apply dotfiles
sh -c "$(curl -fsLS get.chezmoi.io)" -- init --apply rigerc
```

### Common Commands
```bash
# Apply all dotfiles
chezmoi apply

# Apply specific files
chezmoi apply ~/.zshrc

# Edit source files (opens in $EDITOR)
chezmoi edit ~/.zshrc

# Check what would change without applying
chezmoi diff

# Update from remote and apply changes
chezmoi update && chezmoi apply

# Add new file to management
chezmoi add ~/.config/some-app/config

# Remove file from management (keeps actual file)
chezmoi forget ~/.config/some-app/config
```

## Architecture

### Directory Structure
- `dot_*` - Files that will be symlinked to home directory (dot_ becomes .)
- `.chezmoi.toml.tmpl` - Configuration template with prompts for user data
- `.chezmoiscripts/` - Scripts that run during chezmoi operations
- `dot_config/` - Configuration files for ~/.config/
- `.chezmoiignore` - Files to ignore in chezmoi management

### Key Components

#### Configuration Management
- Uses Chezmoi templates (`.tmpl` files) for dynamic configuration
- Integrates with Bitwarden for secrets management via `bitwardenFields`
- Supports different data per machine while sharing most configurations

#### Shell Environment (Zsh + Zinit)
- **Zinit Plugin Manager**: Fast, turbo-charged plugin loading
- **Key Plugins**:
  - `zsh-autosuggestions` - Command suggestions based on history
  - `fast-syntax-highlighting` - Syntax highlighting
  - `fzf-tab` - Fuzzy completion with tab
  - `starship` - Custom prompt
  - `zoxide` - Smart directory jumping
- **Custom Functions**: Interactive directory jumping with fzf integration

#### Terminal Multiplexer (Tmux)
- **TPM Plugin Manager** for package management
- **Key Plugins**: tmux-sensible, tmux-yank, vim-tmux-navigator, tmux-resurrect, catppuccin theme
- **Auto-restore**: Sessions automatically restored on start
- **Navigation**: Vi-style pane navigation and Vim integration

#### Development Tools
- **Modern Replacements**: eza (ls), bat (cat), ripgrep (grep)
- **Git**: Enhanced aliases and lazygit integration
- **Editor**: Neovim as default vim/vi replacement

### Script System

#### Chezmoi Scripts (.chezmoiscripts/)
- **.common.sh**: Shared utilities, logging, and Homebrew management functions
- **run_once_00-install-homebrew.sh**: Automated Homebrew installation
- **run_onchange_01_install_homebrew_packages.sh.tmpl**: Package installation via Brewfile
- **Scripts execute** automatically during `chezmoi apply` based on their filename pattern

#### Script Naming Conventions
- `run_once_*` - Execute only once per machine
- `run_onchange_*` - Execute when specified files change
- `run_onchange_before_*` - Execute before file changes
- `run_once_after_*` - Execute after initial setup

### Data & Templates
- **User Data**: GitHub username/email configured via prompts during init
- **Secrets**: API keys retrieved from Bitwarden using template functions
- **Cross-platform**: Supports Linux (WSL), macOS with platform-specific handling

## Platform Support
- Primary: Linux (WSL2)
- Secondary: macOS (Intel/Apple Silicon)
- Homebrew package manager handles cross-platform package installation
- Zsh and Tmux configurations work consistently across platforms
</file>

<file path="dot_config/fish/fish_plugins">
jorgebucaran/fisher
pure-fish/pure
acomagu/fish-async-prompt
gazorby/fish-abbreviation-tips
</file>

<file path="dot_config/fish/functions/fish_greeting.fish">
function fish_greeting
    fastfetch
end
</file>

<file path="pwsh/install_wsl/Modules/WSL-Helpers.psm1">
# ============================================================================
# WSL Helpers Module
# ============================================================================

<#
.SYNOPSIS
    Provides helper functions for WSL installation scripts.

.DESCRIPTION
    This module contains utility functions for output redirection,
    WSL exit code testing, and output formatting.

.PARAMETER Parameters
    Hashtable containing script parameters and configuration values.
#>

# Accept parameters from the main script
param(
    [Parameter(Mandatory)]
    [hashtable]$Parameters
)

# Extract parameters from the hashtable
$script:Debug = $Parameters.Debug
$script:DefaultDistro = $Parameters.DefaultDistro
$script:DefaultName = $Parameters.DefaultName
$script:DefaultUsername = $Parameters.DefaultUsername
$script:PackageManagerPackages = $Parameters.PackageManagerPackages
$script:DistributionReadyMaxAttempts = $Parameters.DistributionReadyMaxAttempts
$script:DistributionReadyDelaySeconds = $Parameters.DistributionReadyDelaySeconds

# ============================================================================
# Helper Functions
# ============================================================================

function Restart-WSLDistribution {
    <#
    .SYNOPSIS
        Restarts a WSL distribution to apply configuration changes.
    .DESCRIPTION
        Shuts down the specified WSL distribution and waits for it to become ready again.
        This is typically used after configuration changes that require a restart.
    .PARAMETER DistroName
        The name of the distribution to restart.
    .OUTPUTS
        [bool] Returns $true if the distribution became ready after restart, $false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    Write-Section "Restarting WSL Distribution"
    Write-LogMessage "Shutting down WSL distribution to apply changes..." -Level Info
    
    try {
        Stop-WSLDistribution -DistroName $DistroName
        Write-LogMessage "Waiting for distribution to be ready after restart..." -Level Info
        Start-Sleep -Seconds 20
        
        if (-not (Wait-ForDistributionReady -DistroName $DistroName)) {
            Write-LogMessage "Warning: Distribution failed to become ready after restart" -Level Warning
            Write-LogMessage "SSH configuration may not work properly" -Level Warning
            return $false
        }
        else {
            Write-LogMessage "Distribution is ready after restart" -Level Success
            return $true
        }
    }
    catch {
        Write-LogMessage "Failed to restart WSL distribution: $($_.Exception.Message.Trim())" -Level Warning
        Write-LogMessage "SSH configuration may not work properly" -Level Warning
        return $false
    }
}

function Get-OutputRedirection {
    <#
    .SYNOPSIS
        Returns the appropriate output redirection string based on debug mode.
    .DESCRIPTION
        When debug mode is disabled, returns a string to suppress stdout and stderr.
        When debug mode is enabled, returns an empty string to show all output.
    .OUTPUTS
        [string] Output redirection string or empty string.
    #>
    [CmdletBinding()]
    [OutputType([string])]
    param()
    
    if ($script:Debug) {
        return ""
    }
    return " >/dev/null 2>&1"
}

function Test-WSLExitCode {
    <#
    .SYNOPSIS
        Tests if the last WSL command succeeded.
    .DESCRIPTION
        Checks $LASTEXITCODE and throws an exception if it indicates failure.
    .PARAMETER Operation
        Description of the operation for error messages.
    .PARAMETER AllowNonZero
        If specified, non-zero exit codes are acceptable.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Operation,
        
        [switch]$AllowNonZero
    )
    
    if ($LASTEXITCODE -ne 0 -and -not $AllowNonZero) {
        throw "$Operation failed with exit code: $LASTEXITCODE"
    }
}

function Format-WSLOutput {
    <#
    .SYNOPSIS
        Cleans WSL output by removing null characters and trimming whitespace.
        Handles different output modes (debug, quiet, normal) and proper error handling.
    .PARAMETER Output
        The output string to clean.
    .PARAMETER Debug
        Enable debug mode - returns raw output without cleaning.
    .PARAMETER Quiet
        Enable quiet mode - suppresses output unless there's an error.
    .OUTPUTS
        [string] Cleaned output string or empty string for quiet mode.
    #>
    [CmdletBinding()]
    [OutputType([string])]
    param(
        [Parameter(Mandatory, ValueFromPipeline)]
        [AllowEmptyString()]
        [string]$Output,


        [switch]$Quiet
    )
    
    # Clean the output by removing null characters and trimming whitespace
    $CleanedOutput = ($Output -replace "`0", "").Trim()

    if ($script:Debug) {
        # In debug mode, return raw output for troubleshooting
        return $Output
    }
    elseif ($Quiet) {
        # In quiet mode, check if the output contains actual errors vs warnings
        $ErrorPatterns = @(
            "error:",
            "Error:",
            "ERROR:",
            "failed",
            "Failed",
            "FAILED",
            "exception",
            "Exception",
            "EXCEPTION"
        )

        $HasRealError = $false
        foreach ($Pattern in $ErrorPatterns) {
            if ($CleanedOutput -like "*$Pattern*") {
                $HasRealError = $true
                break
            }
        }

        # If no real errors found, return empty string (quiet)
        # If real errors found, return them for visibility
        if ($HasRealError) {
            return $CleanedOutput
        }
        else {
            return ""
        }
    }
    else {
        # Normal mode - return cleaned output
        return $CleanedOutput
    }
}

# Export functions
Export-ModuleMember -Function Get-OutputRedirection, Test-WSLExitCode, Format-WSLOutput, Restart-WSLDistribution
</file>

<file path="pwsh/install_wsl/Modules/WSL-Input.psm1">
# ============================================================================
# WSL Input/Configuration Module
# ============================================================================

<#
.SYNOPSIS
    Provides input gathering and configuration functions for WSL installation.

.DESCRIPTION
    This module contains functions for gathering user input, validating
    configuration, and displaying configuration summaries.

.PARAMETER Parameters
    Hashtable containing script parameters and configuration values.
#>

# Accept parameters from the main script
param(
    [Parameter(Mandatory)]
    [hashtable]$Parameters
)

# Extract parameters from the hashtable
$script:Debug = $Parameters.Debug
$script:DefaultDistro = $Parameters.DefaultDistro
$script:DefaultName = $Parameters.DefaultName
$script:DefaultUsername = $Parameters.DefaultUsername
$script:PackageManagerPackages = $Parameters.PackageManagerPackages
$script:DistributionReadyMaxAttempts = $Parameters.DistributionReadyMaxAttempts
$script:DistributionReadyDelaySeconds = $Parameters.DistributionReadyDelaySeconds

# ============================================================================
# Input Functions
# ============================================================================

function Get-UserInput {
    <#
    .SYNOPSIS
        Prompts user for input with a default value.
    .PARAMETER Prompt
        The prompt text to display.
    .PARAMETER Default
        The default value if user presses Enter.
    .PARAMETER UseDefault
        If true, automatically use default without prompting.
    .OUTPUTS
        [string] The user's input or default value.
    #>
    [CmdletBinding()]
    [OutputType([string])]
    param(
        [Parameter(Mandatory)]
        [string]$Prompt,
        
        [string]$Default,
        
        [switch]$UseDefault
    )
    
    if ($UseDefault -and $Default) {
        Write-LogMessage "Using default value for '$Prompt': $Default" -Level Info
        return $Default
    }
    
    $DisplayDefault = if ($Default) { " [$Default]" } else { "" }
    Write-Host $Prompt -ForegroundColor Blue -NoNewline
    Write-Host $DisplayDefault -ForegroundColor Yellow -NoNewline
    Write-Host ": " -ForegroundColor White -NoNewline
    $UserInput = Read-Host
    
    if ($UserInput) {
        return $UserInput
    }
    
    return $Default
}

function Get-ValidatedUsername {
    <#
    .SYNOPSIS
        Prompts for and validates a Linux username.
    .PARAMETER Default
        The default username value.
    .PARAMETER UseDefault
        If true, automatically use default if valid.
    .OUTPUTS
        [string] A valid Linux username.
    #>
    [CmdletBinding()]
    [OutputType([string])]
    param(
        [string]$Default,
        
        [switch]$UseDefault
    )
    
    if ($UseDefault -and $Default) {
        if (Test-ValidLinuxUsername -Username $Default) {
            Write-LogMessage "Using default username: $Default" -Level Info
            return $Default
        }
        else {
            Write-LogMessage "Default username '$Default' is invalid. Using 'user' instead." -Level Warning
            return 'user'
        }
    }
    
    do {
        $Username = Get-UserInput -Prompt "Username for new user" -Default $Default
        
        if (Test-ValidLinuxUsername -Username $Username) {
            return $Username
        }
        
        Write-LogMessage "Invalid username. Must start with lowercase letter/underscore, contain only lowercase letters, numbers, underscore, hyphen (max 32 chars)" -Level Error
        $Default = $null
    } while ($true)
}

function Get-ConfigurationInput {
    <#
    .SYNOPSIS
        Gathers all configuration inputs from the user or uses defaults.
    .DESCRIPTION
        Collects distribution name, image, username, and optional settings
        like Chezmoi and git configuration.
    .PARAMETER ContinueMode
        Whether running in Continue mode (skips image prompt).
    .PARAMETER UseDefaults
        Whether to use default values without prompting.
    .PARAMETER WithChezmoi
        Whether Chezmoi is explicitly requested.
    .OUTPUTS
        [hashtable] Configuration object with all settings.
    #>
    [CmdletBinding()]
    [OutputType([hashtable])]
    param(
        [switch]$ContinueMode,
        [switch]$UseDefaults,
        [switch]$WithChezmoi
    )
    
    begin {}
    
    process {
        $Config = @{
            DistroImage = $null
            DistroName = $null
            Username = $null
            UseChezmoi = $false
            GitName = $null
            GitEmail = $null
            BW_CLIENTSECRET = $null
        }
        
        # Gather basic inputs
        if (-not $UseDefaults) {
            Write-Host "`nPlease provide the following information (press Enter for defaults):`n"
        }
        else {
            Write-LogMessage "Running with default values (use -WithDefaults:`$false to customize)" -Level Info
        }
        
        if ($ContinueMode) {
            $Config.DistroName = Get-UserInput -Prompt "Distribution name to work with" -Default $script:DefaultName -UseDefault:$UseDefaults
            $Config.Username = Get-ValidatedUsername -Default $script:DefaultUsername -UseDefault:$UseDefaults
        }
        else {
            $Config.DistroImage = Get-UserInput -Prompt "Distribution image" -Default $script:DefaultDistro -UseDefault:$UseDefaults
            $Config.DistroName = Get-UserInput -Prompt "Distribution name to create" -Default $script:DefaultName -UseDefault:$UseDefaults
            $Config.Username = Get-ValidatedUsername -Default $script:DefaultUsername -UseDefault:$UseDefaults
        }
        
        # Determine Chezmoi usage
        if ($WithChezmoi) {
            $Config.UseChezmoi = $true
        }
        elseif (-not $UseDefaults) {
            $ChezmoiPrompt = Read-Host "Use Chezmoi for dotfiles management? (y/N)"
            $Config.UseChezmoi = $ChezmoiPrompt -eq 'y' -or $ChezmoiPrompt -eq 'Y'
        }
        else {
            Write-LogMessage "Chezmoi: Disabled (use -WithChezmoi to enable)" -Level Info
        }
        
        # Get Git configuration if Chezmoi is requested
        if ($Config.UseChezmoi) {
            if (-not (Test-GitAvailable)) {
                Write-LogMessage "Git is not installed or not in PATH. Chezmoi setup will be skipped." -Level Warning
                $Config.UseChezmoi = $false
            }
            else {
                if (-not $UseDefaults) {
                    Write-Host "`nGit configuration (for Chezmoi):`n"
                }
                
                $DefaultGitName = Get-GitConfig -ConfigKey "user.name"
                $Config.GitName = Get-UserInput -Prompt "Github username" -Default $DefaultGitName -UseDefault:$UseDefaults
                
                $DefaultGitEmail = Get-GitConfig -ConfigKey "user.email"
                $Config.GitEmail = Get-UserInput -Prompt "Github email" -Default $DefaultGitEmail -UseDefault:$UseDefaults
                
                # Get Bitwarden Client Secret for Chezmoi
                if (-not $UseDefaults) {
                    Write-Host "`nBitwarden configuration (for Chezmoi):`n"
                }
                
                $Config.BW_CLIENTSECRET = Get-UserInput -Prompt "Bitwarden Client Secret" -Default "" -UseDefault:$UseDefaults
                
                if (-not $Config.GitName -or -not $Config.GitEmail) {
                    Write-LogMessage "Git configuration incomplete. Chezmoi setup will be skipped." -Level Warning
                    $Config.UseChezmoi = $false
                }
            }
        }
        
        return $Config
    }
}

function Show-ConfigurationSummary {
    <#
    .SYNOPSIS
        Displays a summary of the configuration.
    .PARAMETER Config
        The configuration hashtable to display.
    .PARAMETER ContinueMode
        Whether running in Continue mode.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [hashtable]$Config,
        
        [switch]$ContinueMode
    )
    
    Write-Section "Configuration Summary"
    
    if (-not $ContinueMode -and $Config.DistroImage) {
        Write-Host "Distribution Image: " -ForegroundColor White -NoNewline
        Write-Host $Config.DistroImage -ForegroundColor Cyan
    }
    
    Write-Host "Distribution Name:  " -ForegroundColor White -NoNewline
    Write-Host $Config.DistroName -ForegroundColor Cyan
    
    Write-Host "Username:           " -ForegroundColor White -NoNewline
    Write-Host $Config.Username -ForegroundColor Cyan
    
    if ($Config.UseChezmoi) {
        Write-Host "Chezmoi:            " -ForegroundColor White -NoNewline
        Write-Host "Enabled" -ForegroundColor Green
        Write-Host "Git Name:           " -ForegroundColor White -NoNewline
        Write-Host $Config.GitName -ForegroundColor Cyan
        Write-Host "Git Email:          " -ForegroundColor White -NoNewline
        Write-Host $Config.GitEmail -ForegroundColor Cyan
        
        if ($Config.BW_CLIENTSECRET) {
            $MaskedSecret = "*" * $Config.BW_CLIENTSECRET.Length
            Write-Host "Bitwarden Secret:   " -ForegroundColor White -NoNewline
            Write-Host $MaskedSecret -ForegroundColor Green
        }
    }
    else {
        Write-Host "Chezmoi:            " -ForegroundColor White -NoNewline
        Write-Host "Disabled" -ForegroundColor Red
    }
    
    if ($ContinueMode) {
        Write-Host "Mode:               " -ForegroundColor White -NoNewline
        Write-Host "Continue" -ForegroundColor Yellow
    }
    
    Write-Host ""
}

# Export functions
Export-ModuleMember -Function Get-UserInput, Get-ValidatedUsername, 
                              Get-ConfigurationInput, Show-ConfigurationSummary
</file>

<file path="pwsh/install_wsl/Modules/WSL-Install.psd1">
# ============================================================================
# WSL Install Module Manifest
# ============================================================================

@{
    # Script module or binary module file associated with this manifest.
    RootModule = ''

    # Version number of this module.
    ModuleVersion = '1.0.0'

    # Supported PSEditions
    # CompatiblePSEditions = @()

    # ID used to uniquely identify this module
    GUID = '12345678-1234-1234-1234-123456789012'

    # Author of this module
    Author = 'WSL Install Script'

    # Company or vendor of this module
    CompanyName = 'Unknown'

    # Copyright statement for this module
    Copyright = '(c) 2024 WSL Install Script. All rights reserved.'

    # Description of the functionality provided by this module
    Description = 'Modularized WSL installation script for ArchLinux distributions'

    # Minimum version of the PowerShell engine required by this module
    PowerShellVersion = '5.1'

    # Name of the PowerShell host required by this module
    # PowerShellHostName = ''

    # Minimum version of the PowerShell host required by this module
    # PowerShellHostVersion = ''

    # Minimum version of Microsoft .NET Framework required by this module. This prerequisite is valid for the PowerShell Desktop edition only.
    # DotNetFrameworkVersion = ''

    # Minimum version of the common language runtime (CLR) required by this module. This prerequisite is valid for the PowerShell Desktop edition only.
    # CLRVersion = ''

    # Processor architecture (None, X86, Amd64) required by this module
    # ProcessorArchitecture = ''

    # Modules that must be imported into the global environment prior to importing this module
    # RequiredModules = @()

    # Assemblies that must be loaded prior to importing this module
    # RequiredAssemblies = @()

    # Script files (.ps1) that are run in the caller's environment prior to importing this module.
    # ScriptsToProcess = @()

    # Type files (.ps1xml) to be loaded when importing this module
    # TypesToProcess = @()

    # Format files (.ps1xml) to be loaded when importing this module
    # FormatsToProcess = @()

    # Modules to import as nested modules of the module specified in RootModule/ModuleToProcess
    NestedModules = @(
        'WSL-Logging.psm1',
        'WSL-Helpers.psm1',
        'WSL-SystemSetup.psm1',
        'WSL-Validation.psm1',
        'WSL-Command.psm1',
        'WSL-Management.psm1',
        'WSL-PackageManager.psm1',
        'WSL-UserManagement.psm1',
        'WSL-Input.psm1',
        'WSL-Chezmoi.psm1',
        'WSL-SSH.psm1',
        'WSL-Workflow.psm1'
    )

    # Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.
    FunctionsToExport = @(
        'Write-LogMessage',
        'Write-Section',
        'Write-ProgressLog',
        'Get-OutputRedirection',
        'Test-WSLExitCode',
        'Format-WSLOutput',
        'Install-WSLFeatures',
        'Test-ValidLinuxUsername',
        'Test-GitAvailable',
        'Test-DistributionExists',
        'Test-DistributionReady',
        'Test-UserExists',
        'Test-UserSudoAccess',
        'Test-PacmanKeyInitialized',
        'Test-PackageInstalled',
        'Test-ChezmoiConfigured',
        'Invoke-WSLCommand',
        'Invoke-WSLCommandInteractive',
        'Remove-WSLDistribution',
        'Install-WSLDistribution',
        'Wait-ForDistributionReady',
        'Stop-WSLDistribution',
        'Initialize-PacmanKeyring',
        'Install-PacmanPackage',
        'Get-MissingPackages',
        'Install-MissingPackages',
        'Initialize-PackageManager',
        'Test-PackageManagerInitialized',
        'New-WSLUser',
        'Add-UserToSudoers',
        'Test-Configuration',
        'Get-UserInput',
        'Get-ValidatedUsername',
        'Get-ConfigurationInput',
        'Show-ConfigurationSummary',
        'Get-GitConfig',
        'Test-ChezmoiInstallation',
        'Invoke-ChezmoiSetup',
        'Test-SSHDRunning',
        'Get-SSHDPort',
        'Get-WSLIPAddress',
        'New-SSHPortForward',
        'New-SSHFirewallRule',
        'Invoke-SSHConfiguration',
        'Invoke-ContinueChecks',
        'Invoke-ContinueModeWorkflow',
        'Invoke-NormalModeWorkflow',
        'Invoke-ChezmoiWorkflow',
        'Show-CompletionSummary'
    )

    # Cmdlets to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no cmdlets to export.
    CmdletsToExport = @()

    # Variables to export from this module
    VariablesToExport = '*'

    # Aliases to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no aliases to export.
    AliasesToExport = @()

    # DSC resources to export from this module
    # DscResourcesToExport = @()

    # List of all modules packaged with this module
    # ModuleList = @()

    # List of all files packaged with this module
    # FileList = @()

    # Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.
    PrivateData = @{
        PSData = @{
            # Tags applied to this module. These help with module discovery in online galleries.
            Tags = @('WSL', 'Linux', 'ArchLinux', 'Installation', 'PowerShell')

            # A URL to the license for this module.
            LicenseUri = ''

            # A URL to the main website for this project.
            ProjectUri = ''

            # A URL to an icon representing this module.
            IconUri = ''

            # ReleaseNotes of this module
            ReleaseNotes = 'Initial modularized release of WSL installation script'

            # Prerelease string of this module
            # Prerelease = ''

            # Flag to indicate whether the module requires explicit user acceptance for install/update/save
            # RequireLicenseAcceptance = $false

            # External dependent modules of this module
            # ExternalModuleDependencies = @()
        } # End of PSData hashtable
    } # End of PrivateData hashtable

    # HelpInfo URI of this module
    # HelpInfoURI = ''

    # Default prefix for commands exported from this module. Override the default prefix using Import-Module -Prefix.
    # DefaultCommandPrefix = ''
}
</file>

<file path="pwsh/install_wsl/Modules/WSL-PackageManager.psm1">
# ============================================================================
# WSL Package Manager Module
# ============================================================================

<#
.SYNOPSIS
    Provides package management functions for WSL distributions.

.DESCRIPTION
    This module contains functions for initializing pacman, managing packages,
    and checking package manager status.

.PARAMETER Parameters
    Hashtable containing script parameters and configuration values.
#>

# Accept parameters from the main script
param(
    [Parameter(Mandatory)]
    [hashtable]$Parameters
)

# Extract parameters from the hashtable
$script:Debug = $Parameters.Debug
$script:DefaultDistro = $Parameters.DefaultDistro
$script:DefaultName = $Parameters.DefaultName
$script:DefaultUsername = $Parameters.DefaultUsername
$script:PackageManagerPackages = $Parameters.PackageManagerPackages
$script:DistributionReadyMaxAttempts = $Parameters.DistributionReadyMaxAttempts
$script:DistributionReadyDelaySeconds = $Parameters.DistributionReadyDelaySeconds

# ============================================================================
# Package Management Functions
# ============================================================================

function Initialize-PacmanKeyring {
    <#
    .SYNOPSIS
        Initializes the pacman keyring.
    .PARAMETER DistroName
        The name of the WSL distribution.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    # Check if keyring is already initialized to avoid redundant operations
    try {
        $keyringInitialized = Test-PacmanKeyInitialized -DistroName $DistroName

        if ($keyringInitialized) {
            Write-LogMessage "Pacman keyring is already initialized for distribution '$DistroName' - skipping initialization" -Level Success
            return
        }

        Write-LogMessage "Pacman keyring not yet initialized for distribution '$DistroName' - proceeding with initialization..." -Level Info
    }
    catch {
        Write-LogMessage "Failed to check keyring initialization status for distribution '$DistroName': $($_.Exception.Message.Trim())" -Level Warning
        Write-LogMessage "Proceeding with initialization to ensure keyring is properly set up" -Level Warning
    }
    
    Write-LogMessage "Initializing pacman keyring..." -Level Info
    
    try {
        $OutputRedirect = Get-OutputRedirection
        
        # Initialize keyring
        $Command = "pacman-key --init$OutputRedirect"
        Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot -Quiet
        Test-WSLExitCode -Operation "Pacman keyring initialization"
        Write-LogMessage "Pacman keyring initialized successfully" -Level Success
        
        # Populate Arch Linux keys
        Write-LogMessage "Populating Arch Linux keys..." -Level Info
        $Command = "pacman-key --populate archlinux$OutputRedirect"
        Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot -Quiet
        Test-WSLExitCode -Operation "Arch Linux keys population"
        Write-LogMessage "Arch Linux keys populated successfully" -Level Success
    }
    catch {
        Write-LogMessage "Failed to initialize pacman keyring: $($_.Exception.Message.Trim())" -Level Error
        throw
    }
}

function Install-PacmanPackage {
    <#
    .SYNOPSIS
        Installs a single package using pacman.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER PackageName
        The name of the package to install.
    .OUTPUTS
        [bool] True if installation succeeded, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$PackageName
    )
    
    Write-LogMessage "Installing package: $PackageName" -Level Info
    
    try {
        $OutputRedirect = Get-OutputRedirection
        $Command = "pacman -S $PackageName --noconfirm --needed --quiet$OutputRedirect"
        
        Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot -Quiet
        
        if ($LASTEXITCODE -eq 0) {
            Write-LogMessage "Successfully installed package: $PackageName" -Level Success
            return $true
        }
        else {
            Write-LogMessage "Failed to install package: $PackageName" -Level Error
            return $false
        }
    }
    catch {
        Write-LogMessage "Error installing package '$PackageName': $($_.Exception.Message.Trim())" -Level Error
        return $false
    }
}

function Get-MissingPackages {
    <#
    .SYNOPSIS
        Identifies which packages from a list are not installed.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER PackageNames
        Array of package names to check.
    .OUTPUTS
        [string[]] Array of missing package names.
    #>
    [CmdletBinding()]
    [OutputType([string[]])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [Parameter(Mandatory)]
        [string[]]$PackageNames
    )
    
    $MissingPackages = @()
    
    foreach ($Package in $PackageNames) {
        Write-LogMessage "Checking if package '$Package' is installed..." -Level Info
        
        if (-not (Test-PackageInstalled -DistroName $DistroName -PackageName $Package)) {
            Write-LogMessage "Package '$Package' is not installed" -Level Warning
            $MissingPackages += $Package
        }
        else {
            Write-LogMessage "Package '$Package' is installed" -Level Success
        }
    }
    
    return $MissingPackages
}

function Install-MissingPackages {
    <#
    .SYNOPSIS
        Installs all missing packages from a list.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER PackageNames
        Array of package names to install if missing.
    .OUTPUTS
        [bool] True if all packages installed successfully, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [Parameter(Mandatory)]
        [string[]]$PackageNames
    )
    
    $MissingPackages = Get-MissingPackages -DistroName $DistroName -PackageNames $PackageNames
    
    if ($MissingPackages.Count -eq 0) {
        Write-LogMessage "All required packages are already installed" -Level Success
        return $true
    }
    
    Write-LogMessage "Attempting to install $($MissingPackages.Count) missing package(s)..." -Level Info
    $AllSucceeded = $true
    
    foreach ($Package in $MissingPackages) {
        $Result = Install-PacmanPackage -DistroName $DistroName -PackageName $Package
        if (-not $Result) {
            $AllSucceeded = $false
        }
    }
    
    return $AllSucceeded
}

function Initialize-PackageManager {
    <#
    .SYNOPSIS
        Initializes pacman and installs required packages.
    .PARAMETER DistroName
        The name of the WSL distribution.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    Write-Section "Initializing Package Manager"
    
    $OutputRedirect = Get-OutputRedirection
    
    # Initialize pacman keyring
    Initialize-PacmanKeyring -DistroName $DistroName
    
    # Update system packages
    try {
        Write-LogMessage "Updating system packages..." -Level Info
        $Command = "pacman -Syu --noconfirm --quiet$OutputRedirect"
        Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot -Quiet
        Write-LogMessage "System packages updated successfully" -Level Success
        Write-Host ""
    }
    catch {
        Write-LogMessage "System update failed: $($_.Exception.Message.Trim())" -Level Warning
    }
    
    # Install required packages
    Write-LogMessage "Installing required packages..." -Level Info
    $Result = Install-MissingPackages -DistroName $DistroName -PackageNames $script:PackageManagerPackages
    
    if ($Result) {
        Write-LogMessage "All required packages installed successfully" -Level Success
    }
    else {
        Write-LogMessage "Some packages failed to install" -Level Warning
    }
    
    Write-LogMessage "Package manager initialization complete" -Level Success
}

function Test-PackageManagerInitialized {
    <#
    .SYNOPSIS
        Checks if the package manager is fully initialized.
    .DESCRIPTION
        Verifies that sudo is available, pacman keyring is initialized,
        and required packages are installed.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .OUTPUTS
        [hashtable] Status object with initialization details.
    #>
    [CmdletBinding()]
    [OutputType([hashtable])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    Write-LogMessage "Checking package manager initialization..." -Level Info
    
    $Status = @{
        SudoAvailable = $false
        KeyringInitialized = $false
        AllPackagesInstalled = $false
        MissingPackages = @()
    }
    
    # Check if the default user can use sudo
    try {
        if (Test-UserExists -DistroName $DistroName -Username $script:DefaultUsername) {
            $SudoAccess = Test-UserSudoAccess -DistroName $DistroName -Username $script:DefaultUsername
            if ($SudoAccess) {
                $Status.SudoAvailable = $true
                Write-LogMessage "Default user '$($script:DefaultUsername)' can use sudo" -Level Success
            }
            else {
                Write-LogMessage "Default user '$($script:DefaultUsername)' cannot use sudo" -Level Warning
                return $Status
            }
        }
        else {
            Write-LogMessage "Default user '$($script:DefaultUsername)' does not exist" -Level Warning
            return $Status
        }
    }
    catch {
        Write-LogMessage "Failed to check sudo access for default user" -Level Warning
        return $Status
    }
    
    # Check keyring initialization
    $Status.KeyringInitialized = Test-PacmanKeyInitialized -DistroName $DistroName
    
    if (-not $Status.KeyringInitialized) {
        Write-LogMessage "Pacman keyring is not initialized" -Level Warning
        return $Status
    }
    
    Write-LogMessage "Pacman keyring is initialized" -Level Success
    
    # Check required packages
    $Status.MissingPackages = Get-MissingPackages -DistroName $DistroName -PackageNames $script:PackageManagerPackages
    $Status.AllPackagesInstalled = ($Status.MissingPackages.Count -eq 0)
    
    if ($Status.AllPackagesInstalled) {
        Write-LogMessage "All required packages are installed" -Level Success
    }
    else {
        Write-LogMessage "Missing packages: $($Status.MissingPackages -join ', ')" -Level Warning
    }
    
    return $Status
}

# Export functions
Export-ModuleMember -Function Initialize-PacmanKeyring, Install-PacmanPackage, 
                              Get-MissingPackages, Install-MissingPackages, 
                              Initialize-PackageManager, Test-PackageManagerInitialized
</file>

<file path="dot_config/alacritty/alacritty.toml">
[terminal]
shell = { program = 'C:\Program Files\WSL\wsl.exe', args = ["-d newarchlinux -u bondg --cd ~"] }

[font]
normal = { family = "Iosevka Nerd Font", style = "Regular" }
bold = { family = "Iosevka Nerd Font", style = "Bold" }
italic = { family = "Iosevka Nerd Font", style = "Italic" }
bold_italic = { family = "Iosevka Nerd Font", style = "Bold Italic" }
size = 12.0

[window]
opacity = 0.95
padding = { x = 5, y = 5 }
blur = true

[cursor]
style = { shape = "Block", blinking = "On"}

[general]
import = [
    "./themes/monokai_charcoal.toml"
]
</file>

<file path="pwsh/install_wsl/Modules/WSL-Logging.psm1">
# ============================================================================
# WSL Logging Module
# ============================================================================

<#
.SYNOPSIS
    Provides logging functionality for WSL installation scripts.

.DESCRIPTION
    This module contains functions for formatted logging with timestamps,
    color-coded severity levels, section headers, and progress logging.

.PARAMETER Parameters
    Hashtable containing script parameters and configuration values.
#>

# Accept parameters from the main script
param(
    [Parameter(Mandatory)]
    [hashtable]$Parameters
)

# Extract parameters from the hashtable
$script:Debug = $Parameters.Debug
$script:DryRun = $Parameters.DryRun
$script:DefaultDistro = $Parameters.DefaultDistro
$script:DefaultName = $Parameters.DefaultName
$script:DefaultUsername = $Parameters.DefaultUsername
$script:PackageManagerPackages = $Parameters.PackageManagerPackages
$script:DistributionReadyMaxAttempts = $Parameters.DistributionReadyMaxAttempts
$script:DistributionReadyDelaySeconds = $Parameters.DistributionReadyDelaySeconds

# ============================================================================
# Logging Functions
# ============================================================================

function Write-LogMessage {
    <#
    .SYNOPSIS
        Writes formatted log messages with simplified output for non-debug modes.
    .DESCRIPTION
        Outputs log messages with clean formatting in normal mode and full detail in debug mode.
    .PARAMETER Message
        The message to log.
    .PARAMETER Level
        The severity level: Info, Warning, Error, Success, or Debug.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory, ValueFromPipeline)]
        [string]$Message,

        [ValidateSet('Info', 'Warning', 'Error', 'Success', 'Debug')]
        [string]$Level = 'Info'
    )

    # Skip debug messages unless in debug mode
    if ($Level -eq 'Debug' -and -not $script:Debug) {
        return
    }

    if ($Level -eq 'Error') {
        $Message = $Message.Trim()
    }

    # Simplified formatting for non-debug modes
    if (-not $script:Debug) {
        # Use icons for quick visual recognition
        $Icon = switch ($Level) {
            'Warning' { "⚠️ " }
            'Error' { "❌ " }
            'Success' { "✅ " }
            default { "" }
        }

        $Color = @{
            'Warning' = 'Yellow'
            'Error' = 'Red'
            'Success' = 'Green'
        }[$Level]

        if ($Color) {
            Write-Host "$Icon$Message" -ForegroundColor $Color
        } else {
            Write-Host $Message
        }
        return
    }

    # Full formatting for debug mode (current behavior)
    $Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    $Color = @{
        'Info'    = 'Cyan'
        'Warning' = 'Yellow'
        'Error'   = 'Red'
        'Success' = 'Green'
        'Debug'   = 'Magenta'
    }[$Level]

    # Get calling function name for debug mode
    $CallerInfo = ""
    if ($script:Debug) {
        $CallStack = Get-PSCallStack
        if ($CallStack.Count -gt 1) {
            $Caller = $CallStack[1].Command
            if ($Caller -and $Caller -ne "Write-LogMessage" -and $Caller -ne "<ScriptBlock>") {
                $CallerInfo = "[$Caller] "
            }
        }
    }

    Write-Host "[$Timestamp] " -ForegroundColor Gray -NoNewline
    Write-Host "[$Level] " -ForegroundColor $Color -NoNewline
    if ($CallerInfo) {
        Write-Host $CallerInfo -ForegroundColor Magenta -NoNewline
    }
    Write-Host $Message -ForegroundColor White
}

function Write-Section {
    <#
    .SYNOPSIS
        Writes a formatted section header with simplified output for non-debug modes.
    .PARAMETER Title
        The section title to display.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Title
    )

    # Simplified section headers for non-debug modes
    if (-not $script:Debug) {
        Write-Host "`n▶ $Title" -ForegroundColor White
        return
    }

    # Full section headers for debug mode (current behavior)
    Write-Host "`n" -NoNewline
    Write-Host ("=" * 70) -ForegroundColor Magenta
    Write-Host $Title -ForegroundColor Magenta -BackgroundColor Black
    Write-Host ("=" * 70) -ForegroundColor Magenta
}

function Write-ProgressLog {
    <#
    .SYNOPSIS
        Writes a progress bar with optional activity and status updates.
    .PARAMETER Activity
        The activity being performed.
    .PARAMETER Status
        The current status.
    .PARAMETER PercentComplete
        Percentage completion (0-100).
    .PARAMETER SecondsRemaining
        Estimated seconds remaining.
    .PARAMETER CurrentOperation
        Description of current operation.
    .PARAMETER Complete
        Mark the progress as complete.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Activity,

        [string]$Status = "",
        [int]$PercentComplete = -1,
        [int]$SecondsRemaining = -1,
        [string]$CurrentOperation = "",
        [switch]$Complete
    )

    # Skip progress bars in dry run mode
    if ($script:DryRun) {
        return
    }

    if ($Complete) {
        Write-Progress -Activity $Activity -Completed
        return
    }

    $ProgressParams = @{
        Activity = $Activity
    }

    if ($Status) { $ProgressParams.Status = $Status }
    if ($PercentComplete -ge 0) { $ProgressParams.PercentComplete = $PercentComplete }
    if ($SecondsRemaining -ge 0) { $ProgressParams.SecondsRemaining = $SecondsRemaining }
    if ($CurrentOperation) { $ProgressParams.CurrentOperation = $CurrentOperation }

    Write-Progress @ProgressParams
}

function Write-DryRunAction {
    <#
    .SYNOPSIS
        Writes a dry run action message showing what would be executed.
    .PARAMETER Action
        The action that would be performed.
    .PARAMETER Target
        The target of the action.
    .PARAMETER Details
        Additional details about the action.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Action,

        [string]$Target = "",
        [string]$Details = ""
    )

    if (-not $script:DryRun) {
        return
    }

    $Message = "Would $Action"
    if ($Target) {
        $Message += " '$Target'"
    }
    if ($Details) {
        $Message += " ($Details)"
    }

    Write-Host "  🔄 $Message" -ForegroundColor Cyan
}

# Export functions
Export-ModuleMember -Function Write-LogMessage, Write-Section, Write-ProgressLog, Write-DryRunAction
</file>

<file path="pwsh/install_wsl/Modules/WSL-Management.psm1">
# ============================================================================
# WSL Management Module
# ============================================================================

<#
.SYNOPSIS
    Provides WSL distribution management functions.

.DESCRIPTION
    This module contains functions for installing, removing, and managing
    WSL distributions including waiting for them to be ready.

.PARAMETER Parameters
    Hashtable containing script parameters and configuration values.
#>

# Accept parameters from the main script
param(
    [Parameter(Mandatory)]
    [hashtable]$Parameters
)

# Extract parameters from the hashtable
$script:Debug = $Parameters.Debug
$script:DefaultDistro = $Parameters.DefaultDistro
$script:DefaultName = $Parameters.DefaultName
$script:DefaultUsername = $Parameters.DefaultUsername
$script:PackageManagerPackages = $Parameters.PackageManagerPackages
$script:DistributionReadyMaxAttempts = $Parameters.DistributionReadyMaxAttempts
$script:DistributionReadyDelaySeconds = $Parameters.DistributionReadyDelaySeconds

# ============================================================================
# WSL Management Functions
# ============================================================================

function Remove-WSLDistribution {
    <#
    .SYNOPSIS
        Removes an existing WSL distribution.
    .PARAMETER DistroName
        The name of the distribution to remove.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    Write-LogMessage "Removing existing WSL distribution: $DistroName" -Level Warning
    
    try {
        $Output = wsl --unregister $DistroName 2>&1
        Test-WSLExitCode -Operation "Distribution removal"
        Write-LogMessage "Successfully removed distribution: $DistroName" -Level Success
    }
    catch {
        Write-LogMessage "Failed to remove distribution: $($_.Exception.Message.Trim())" -Level Error
        throw
    }
}

function Install-WSLDistribution {
    <#
    .SYNOPSIS
        Installs a new WSL distribution from image.
    .PARAMETER ImageName
        The name of the distribution image to install.
    .PARAMETER DistroName
        The name to assign to the installed distribution.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$ImageName,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    Write-LogMessage "Preparing to install WSL distribution: $DistroName from image: $ImageName" -Level Info
    
    # Remove existing distribution if present
    if (Test-DistributionExists -DistroName $DistroName) {
        Write-LogMessage "Distribution '$DistroName' already exists. Removing it first..." -Level Warning
        Remove-WSLDistribution -DistroName $DistroName
        Start-Sleep -Seconds 3
    }
    
    Write-LogMessage "Starting installation - this may take several minutes..." -Level Info
    
    try {
        $Output = wsl --install $ImageName --name $DistroName --no-launch
        Test-WSLExitCode -Operation "Distribution installation"
        Write-LogMessage "WSL distribution installation completed" -Level Success
    }
    catch {
        Write-LogMessage "Failed to install distribution: $($_.Exception.Message.Trim())" -Level Error
        throw
    }
}

function Wait-ForDistributionReady {
    <#
    .SYNOPSIS
        Waits for WSL distribution to be fully ready with progress feedback.
    .PARAMETER DistroName
        The name of the distribution to wait for.
    .PARAMETER MaxAttempts
        Maximum number of attempts (default from constants).
    .PARAMETER DelaySeconds
        Delay between attempts (default from constants).
    .OUTPUTS
        [bool] True if distribution became ready, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [int]$MaxAttempts = $script:DistributionReadyMaxAttempts,
        [int]$DelaySeconds = $script:DistributionReadyDelaySeconds
    )
    
    $Activity = "Waiting for WSL Distribution '$DistroName' to be Ready"
    Write-LogMessage "Waiting for distribution to be ready..." -Level Info
    Start-Sleep(4)
    for ($i = 1; $i -le $MaxAttempts; $i++) {
        $PercentComplete = [math]::Round(($i / $MaxAttempts) * 100)
        $SecondsRemaining = ($MaxAttempts - $i) * $DelaySeconds
        $Status = "Attempt $i of $MaxAttempts"
        
        Write-ProgressLog -Activity $Activity -Status $Status -PercentComplete $PercentComplete -SecondsRemaining $SecondsRemaining -CurrentOperation "Checking distribution status..."
        
        if (Test-DistributionReady -DistroName $DistroName) {
            # Verify bash is available
            try {
                $BashCheck = wsl -d $DistroName -u root -- bash -c "echo 'bash_ready'" 2>&1 | Out-String
                if ($BashCheck -match "bash_ready") {
                    Write-ProgressLog -Activity $Activity -Complete
                    Write-LogMessage "Distribution is ready after $i attempt(s)" -Level Success
                    return $true
                }
            }
            catch {
                Write-LogMessage "Bash verification failed, retrying..." -Level Warning
            }
        }
        
        if ($i -lt $MaxAttempts) {
            Start-Sleep -Seconds $DelaySeconds
        }
    }
    
    Write-ProgressLog -Activity $Activity -Complete
    Write-LogMessage "Distribution did not become ready after $MaxAttempts attempts" -Level Error
    return $false
}

function Stop-WSLDistribution {
    <#
    .SYNOPSIS
        Terminates a running WSL distribution.
    .PARAMETER DistroName
        The name of the distribution to terminate.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    Write-LogMessage "Shutting down WSL distribution: $DistroName" -Level Info
    
    try {
        $Output = wsl --terminate $DistroName 2>&1
        Test-WSLExitCode -Operation "Distribution termination"
        Write-LogMessage "WSL distribution shut down successfully" -Level Success
    }
    catch {
        Write-LogMessage "Failed to terminate distribution: $($_.Exception.Message.Trim())" -Level Error
        throw
    }
}

function Set-WSLDefaultDistribution {
    <#
    .SYNOPSIS
        Sets a WSL distribution as the default.
    .PARAMETER DistroName
        The name of the distribution to set as default.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    Write-LogMessage "Setting '$DistroName' as the default WSL distribution..." -Level Info
    
    try {
        $Output = wsl --set-default $DistroName 2>&1
        Test-WSLExitCode -Operation "Setting default distribution"
        Write-LogMessage "'$DistroName' is now the default WSL distribution" -Level Success
    }
    catch {
        Write-LogMessage "Failed to set default distribution: $($_.Exception.Message.Trim())" -Level Error
        throw
    }
}

# Export functions
Export-ModuleMember -Function Remove-WSLDistribution, Install-WSLDistribution,
                              Wait-ForDistributionReady, Stop-WSLDistribution,
                              Set-WSLDefaultDistribution
</file>

<file path="pwsh/install_wsl/Modules/WSL-SystemSetup.psm1">
# ============================================================================
# WSL System Setup Module
# ============================================================================

<#
.SYNOPSIS
    Provides WSL system component installation functions.

.DESCRIPTION
    This module contains functions for installing WSL features,
    updating the WSL kernel, and setting WSL2 as default.

.PARAMETER Parameters
    Hashtable containing script parameters and configuration values.
#>

# Accept parameters from the main script
param(
    [Parameter(Mandatory)]
    [hashtable]$Parameters
)

# Extract parameters from the hashtable
$script:Debug = $Parameters.Debug
$script:DryRun = $Parameters.DryRun
$script:DefaultDistro = $Parameters.DefaultDistro
$script:DefaultName = $Parameters.DefaultName
$script:DefaultUsername = $Parameters.DefaultUsername
$script:PackageManagerPackages = $Parameters.PackageManagerPackages
$script:DistributionReadyMaxAttempts = $Parameters.DistributionReadyMaxAttempts
$script:DistributionReadyDelaySeconds = $Parameters.DistributionReadyDelaySeconds

# ============================================================================
# WSL System Setup Functions
# ============================================================================

function Install-WSLFeatures {
    <#
    .SYNOPSIS
        Installs required Windows features for WSL.
    .DESCRIPTION
        Installs Windows Subsystem for Linux and Virtual Machine Platform features,
        updates WSL kernel, and sets WSL2 as the default version.
    .OUTPUTS
        [bool] True if reboot is required, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param()

    # Show what would be done in dry run mode
    if ($script:DryRun) {
        Write-DryRunAction -Action "check Windows Subsystem for Linux feature"
        Write-DryRunAction -Action "check Virtual Machine Platform feature"
        Write-DryRunAction -Action "update WSL kernel"
        Write-DryRunAction -Action "set WSL2 as default version"
        Write-DryRunAction -Action "install WSL features if needed"
        return $false
    }

    $RebootRequired = $false
    $FeaturesInstalled = @()

    # Install WSL feature
    try {
        $WslFeature = Get-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux

        if ($WslFeature.State -ne 'Enabled') {
            $WslInstall = Enable-WindowsOptionalFeature -Online -NoRestart -FeatureName Microsoft-Windows-Subsystem-Linux
            if ($WslInstall.RestartNeeded) {
                $RebootRequired = $true
            }
            $FeaturesInstalled += "Windows Subsystem for Linux"
        }
    }
    catch {
        Write-LogMessage "Failed to install Windows Subsystem for Linux: $($_.Exception.Message.Trim())" -Level Error
        throw
    }

    # Install Virtual Machine Platform
    try {
        $VmpFeature = Get-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform

        if ($VmpFeature.State -ne 'Enabled') {
            $VmpInstall = Enable-WindowsOptionalFeature -Online -NoRestart -FeatureName VirtualMachinePlatform
            if ($VmpInstall.RestartNeeded) {
                $RebootRequired = $true
            }
            $FeaturesInstalled += "Virtual Machine Platform"
        }
    }
    catch {
        Write-LogMessage "Failed to install Virtual Machine Platform: $($_.Exception.Message.Trim())" -Level Error
        throw
    }

    # Update WSL kernel
    try {
        $null = wsl --update 2>&1
    }
    catch {
        Write-LogMessage "WSL kernel update failed: $($_.Exception.Message.Trim())" -Level Warning
    }

    # Set WSL2 as default
    try {
        $null = wsl --set-default-version 2 2>&1
    }
    catch {
        Write-LogMessage "Failed to set WSL2 as default: $($_.Exception.Message.Trim())" -Level Warning
    }

    # Report results
    if ($FeaturesInstalled.Count -gt 0) {
        if ($RebootRequired) {
            Write-LogMessage "WSL features installed - restart required" -Level Warning
        }
        else {
            Write-LogMessage "WSL features installed successfully" -Level Success
        }
    }
    else {
        Write-LogMessage "WSL features already configured" -Level Success
    }

    return $RebootRequired
}

# Export functions
Export-ModuleMember -Function Install-WSLFeatures
</file>

<file path=".chezmoiexternals/externals.toml">
{{- $arch := .chezmoi.arch -}}
{{- $os := .chezmoi.os -}}

{{- if eq $arch "amd64" -}}
{{-   $arch = "amd64" -}}
{{- else if eq $arch "arm64" -}}
{{-   $arch = "arm64" -}}
{{- else if hasPrefix "arm" $arch -}}
{{-   $arch = "arm" -}}
{{- end -}}

{{- if or (eq $os "darwin") (eq $os "linux") (eq $os "freebsd") -}}

{{- else if eq $os "android" -}}
{{-   $os = "linux" -}}
{{- end -}}

{{- $version := "latest" -}}
{{- $target := printf "%s-%s" $os $arch -}}

# Oh My Posh executable
[".local/bin/oh-my-posh"]
    type = "file"
    url = "https://cdn.ohmyposh.dev/releases/{{ $version }}/posh-{{ $target }}"
    executable = true
    refreshPeriod = "168h"  # Check for updates weekly

# Oh My Posh themes
[".local/share/oh-my-posh/themes"]
    type = "archive"
    url = "https://cdn.ohmyposh.dev/releases/latest/themes.zip"
    exact = true
    stripComponents = 0
    refreshPeriod = "168h"  # Check for updates weekly

# Tmux TPM Plugin Manager
[".config/tmux/plugins/tpm"]
    type = "git-repo"
    url = "https://github.com/tmux-plugins/tpm"

# Alacritty themes
[".config/alacritty/themes"]
    type = "git-repo"
    url = "https://github.com/alacritty/alacritty-theme.git"

# Git aliases
[".config/git/alias"]
    type = "file"
    url = "https://raw.githubusercontent.com/GitAlias/gitalias/main/gitalias.txt"

# LazyVim
[".config/nvim"]
    type = "git-repo"
    url = "https://github.com/LazyVim/starter"

# Zinit Zsh Plugin Manager
[".local/share/zinit"]
    type = "git-repo"
    url = "https://github.com/zdharma-continuum/zinit.git"
</file>

<file path=".chezmoiignore">
CLAUDE.md
.claude/*
README.MD
pwsh/*
docs/*
.bw_session
{{- if eq .chezmoi.os "android" }}
.local/bin
.config/alacritty
.config/mods
.config/nano
.config/opencode
.config/zsh
.config/starship.toml
.tmux.config
.claude.json
.bashrc
{{- else if eq .chezmoi.os "linux" }}
.shortcuts/
{{- end }}
</file>

<file path="dot_bashrc">
#
# ~/.bashrc
#

# If not running interactively, don't do anything
[[ $- != *i* ]] && return

alias ls='ls --color=auto'
alias grep='grep --color=auto'
PS1='[\u@\h \W]\$ '

eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"

# start fish/tmux
# Auto-start tmux on login
if command -v tmux >/dev/null 2>&1; then
  if [[ -z "$TMUX" ]] && [[ $- == *i* ]]; then
    tmux attach -t main || tmux new -s main
  fi
fi
</file>

<file path="dot_env.tmpl">
{{- if ne .chezmoi.os "android" }}
export EDITOR="micro"
export VISUAL="nvim"
export BROWSER="wlsview"

export TERM="xterm-256color"

# Go workspace
export GOPATH="$HOME/.go"

export FZF_DEFAULT_OPTS="--height 40% --layout reverse --border --inline-info"
export FZF_DEFAULT_COMMAND="rg --files --hidden --follow --glob '!.git/*'"
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_ALT_C_COMMAND="fd --type d --hidden --follow --exclude '.git'"

export GIT_MERGE_AUTOEDIT="no"
export GIT_PAGER="delta --dark"

export XDG_CACHE_HOME="$HOME/.cache"
export XDG_CONFIG_HOME="$HOME/.config"
export XDG_DATA_HOME="$HOME/.local/share"
export XDG_STATE_HOME="$HOME/.local/state"

export BAT_CONFIG_PATH="$HOME/.config/bat/config"
export BAT_THEME="GitHub"

# TOKENS
export OPENROUTER_API_KEY="{{ .OPENROUTER_API_KEY }}"
export ZAI_API_KEY="{{ .ZAI_API_KEY }}"
export GITHUB_TOKEN="{{ .GITHUB_TOKEN }}"
export ANTHROPIC_AUTH_TOKEN="$ZAI_API_KEY"

{{- end }}
export LANG="en_US.UTF-8"
export LC_CTYPE="en_US.UTF-8"
export LC_ALL="en_US.UTF-8"

export PATH="$HOME/bin:$PATH"
export PATH="$HOME/.local/bin:$PATH"
export PATH="$GOPATH/bin:$PATH"
</file>

<file path="dot_local/bin/ingest.sh">
#!/bin/bash

# Default ignore patterns for files and directories
DEFAULT_IGNORE_PATTERNS=(
    ".git"
    ".gitignore"
    "__pycache__"
    "node_modules"
    ".venv"
    ".vscode"
    ".idea"
    "*.log"
    "*.tmp"
    "digest.txt"
    ".DS_Store"
    "Thumbs.db"
    "*.egg-info"
    "dist"
    "build"
    ".pytest_cache"
    ".coverage"
    "htmlcov"
    "*.pyc"
    "*.pyo"
    # Common non-source file patterns
    "runs/*"
    "videos/*"
    "wandb/*"
    "img/*"
    "logs/*"
    # Binary file extensions
    "*.mp4"
    "*.avi"
    "*.mov"
    "*.mkv"
    "*.jpg"
    "*.jpeg"
    "*.png"
    "*.gif"
    "*.bmp"
    "*.svg"
    "*.ico"
    "*.pdf"
    "*.zip"
    "*.tar"
    "*.gz"
    "*.rar"
    "*.exe"
    "*.dll"
    "*.so"
    "*.dylib"
    "*.bin"
    "*.dat"
    "*.pt"
    "*.pth"
    "*.pkl"
    "*.pickle"
    "*.wandb"
    "*.tfevents.*"
    "*.model"
    "*.ckpt"
    "*.checkpoint"
    "*.safetensors"
)

# Configuration
MAX_FILE_SIZE=$((1024 * 1024))  # 1MB default max file size
TEXT_FILE_EXTENSIONS=("py" "js" "ts" "java" "cpp" "c" "h" "hpp" "cs" "php" "rb" "go" "rs" "swift" "kt" "scala" "sh" "bash" "zsh" "fish" "ps1" "bat" "cmd" "html" "htm" "css" "scss" "sass" "less" "xml" "json" "yaml" "yml" "toml" "ini" "cfg" "conf" "md" "txt" "rst" "tex" "sql" "r" "m" "pl" "lua" "vim" "dockerfile" "makefile" "cmake" "requirements.txt" "setup.py" "package.json" "tsconfig.json" "webpack.config.js" "babel.config.js" ".eslintrc.js" ".prettierrc" "gitignore" "gitattributes" "editorconfig" "license" "readme" "changelog" "contributing" "install" "news" "authors" "history" "todo" "faq" "security" "conduct" "changes" "version" "manifest" "metadata" "diff" "patch" "ipynb")

# Show help information
show_help() {
    echo "Usage: $0 [options] [source directory]"
    echo ""
    echo "Options:"
    echo "  -o, --output FILE     Output file path (default: digest.txt, use '-' for stdout)"
    echo "  -i, --include PATTERN Include files matching pattern (can be used multiple times)"
    echo "  -e, --exclude PATTERN Exclude files matching pattern (can be used multiple times)"
    echo "  -s, --max-size SIZE   Maximum file size in bytes (default: 1MB)"
    echo "  --no-gitignore        Do not use patterns from .gitignore for exclusion" 
    echo "  -d, --debug           Enable debug output"
    echo "  -h, --help            Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 /path/to/project"
    echo "  $0 -o summary.txt -i \"*.py\" -i \"*.js\" /path/to/project"
    echo "  $0 --output - /path/to/project  # Output to stdout"
    echo "  $0 -s 2M /path/to/project  # Set max file size to 2MB"
}

# Parse command line arguments
OUTPUT_FILE="digest.txt"
SOURCE_DIR="."
INCLUDE_PATTERNS=()
EXCLUDE_PATTERNS=()
USE_GITIGNORE=true
DEBUG=false



while [[ $# -gt 0 ]]; do
    case $1 in
        -o|--output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -i|--include)
            INCLUDE_PATTERNS+=("$2")
            shift 2
            ;;
        -e|--exclude)
            EXCLUDE_PATTERNS+=("$2")
            shift 2
            ;;
        -s|--max-size)
            # Parse size with optional suffix (K, M, G)
            if [[ "$2" =~ ^([0-9]+)([KMG]?)$ ]]; then
                size="${BASH_REMATCH[1]}"
                suffix="${BASH_REMATCH[2]}"
                case "$suffix" in
                    K) MAX_FILE_SIZE=$((size * 1024)) ;;
                    M) MAX_FILE_SIZE=$((size * 1024 * 1024)) ;;
                    G) MAX_FILE_SIZE=$((size * 1024 * 1024 * 1024)) ;;
                    *) MAX_FILE_SIZE=$size ;;
                esac
            else
                echo "Error: Invalid size format: $2" >&2
                exit 1
            fi
            shift 2
            ;;

        --no-gitignore)
            USE_GITIGNORE=false
            shift
            ;;

        -d|--debug)
            DEBUG=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
        *)
            SOURCE_DIR="$1"
            shift
            ;;
    esac
done

# Debug function
debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo "DEBUG: $1" >&2
    fi
}


# Convert to absolute path
SOURCE_DIR=$(realpath "$SOURCE_DIR")

# Resolve output file absolute path (if not stdout)
OUTPUT_ABS=""
if [[ "$OUTPUT_FILE" != "-" ]]; then
    OUTPUT_ABS=$(realpath -m "$OUTPUT_FILE" 2>/dev/null || echo "")
fi

# Check if source directory exists
if [[ ! -d "$SOURCE_DIR" ]]; then
    echo "Error: Source directory does not exist: $SOURCE_DIR" >&2
    exit 1
fi

# Read .gitignore file and add to ignore patterns
IGNORE_PATTERNS=("${DEFAULT_IGNORE_PATTERNS[@]}")
if [[ "$USE_GITIGNORE" == "true" ]]; then
    if [[ -f "$SOURCE_DIR/.gitignore" ]]; then
        debug "Using patterns from .gitignore"
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Strip trailing CR (for CRLF files) and trim leading/trailing whitespace
            line="${line%$'\r'}"
            line="$(printf '%s' "$line" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
            # Skip empty lines and comments
            if [[ -n "$line" && ! "$line" =~ ^# ]]; then
                IGNORE_PATTERNS+=("$line")
            fi
        done < "$SOURCE_DIR/.gitignore"
    fi
else
    debug "Ignoring .gitignore file as requested"
fi

# Merge exclude patterns
ALL_IGNORE_PATTERNS=("${IGNORE_PATTERNS[@]}" "${EXCLUDE_PATTERNS[@]}")


# Check if file extension is a text file
is_text_extension() {
    local file="$1"
    local extension="${file##*.}"
    local filename=$(basename "$file" | tr '[:upper:]' '[:lower:]')
    
    # Check against known text file extensions
    for ext in "${TEXT_FILE_EXTENSIONS[@]}"; do
        if [[ "$extension" == "$ext" || "$filename" == "$ext" ]]; then
            return 0
        fi
    done
    
    return 1
}

# Convert Jupyter notebook to markdown
convert_ipynb_to_markdown() {
    local file="$1"
    
    # Try using nbconvert if available
    if command -v jupyter >/dev/null 2>&1; then
        jupyter nbconvert --to markdown --stdout "$file" 2>/dev/null
        return $?
    fi
    
    # Try using nbconvert directly
    if command -v jupyter-nbconvert >/dev/null 2>&1; then
        jupyter-nbconvert --to markdown --stdout "$file" 2>/dev/null
        return $?
    fi
    
    # Fallback: parse JSON manually using jq if available
    if command -v jq >/dev/null 2>&1; then
        local cells=$(jq -r '.cells[] | 
            if .cell_type == "markdown" then
                "# Markdown Cell\n" + (.source | join("")) + "\n"
            elif .cell_type == "code" then
                "# Code Cell\n```python\n" + (.source | join("")) + "\n```\n" +
                if .outputs | length > 0 then
                    "# Output\n" + (
                        .outputs[] | 
                        if .text then
                            (.text | join(""))
                        elif .data then
                            (.data["text/plain"] // [] | join(""))
                        else
                            ""
                        end
                    ) + "\n"
                else
                    ""
                end
            else
                ""
            end
        ' "$file" 2>/dev/null)
        
        if [[ $? -eq 0 && -n "$cells" ]]; then
            echo "$cells"
            return 0
        fi
    fi
    
    # If neither nbconvert nor jq is available, just dump the raw content
    return 1
}

# Check if file is binary using multiple methods
is_binary() {
    local file="$1"
    local file_size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "0")
    
    # Check file size first
    if [[ $file_size -gt $MAX_FILE_SIZE ]]; then
        debug "File $file is too large ($file_size bytes > $MAX_FILE_SIZE bytes)"
        return 0
    fi
    
    # Check if it's a known text file extension or filename
    if is_text_extension "$file"; then
        debug "File $file has text extension"
        return 1
    fi
    
    # Check file extension against common binary extensions
    local extension="${file##*.}"
    case "$extension" in
        mp4|avi|mov|mkv|jpg|jpeg|png|gif|bmp|svg|ico|pdf|zip|tar|gz|rar|exe|dll|so|dylib|bin|dat|pt|pth|pkl|pickle|wandb|model|ckpt|checkpoint|safetensors)
            debug "File $file is binary (extension: $extension)"
            return 0
            ;;
    esac
    
    # Use file command to detect file type
    if command -v file >/dev/null 2>&1; then
        local file_type=$(file -b --mime-type "$file" 2>/dev/null)
        # Treat most application/* (except common text-y ones) and any image/*, video/*, audio/* as binary
        if [[ $file_type == "application/octet-stream" ]] || \
           [[ $file_type == image/* ]] || [[ $file_type == video/* ]] || [[ $file_type == audio/* ]] || \
           ( [[ $file_type == application/* ]] && [[ $file_type != application/json ]] && [[ $file_type != application/xml ]] && [[ $file_type != application/x-yaml ]] && [[ $file_type != application/x-tex ]] ); then
            debug "File $file is binary (mime type: $file_type)"
            return 0
        fi
    else
        # Fallback: check if file contains null bytes
        if head -c 1024 "$file" 2>/dev/null | grep -q $'\0'; then
            debug "File $file is binary (contains null bytes)"
            return 0
        fi
    fi
    
    return 1
}

# Check if path matches any pattern
matches_pattern() {
    local path="$1"
    shift
    local patterns=("$@")

    for pattern in "${patterns[@]}"; do
        # Convert path to relative path
        local rel_path="${path#$SOURCE_DIR/}"

        # Normalize pattern: strip leading './' and leading '/'
        local pat="$pattern"
        [[ "$pat" == ./* ]] && pat="${pat#./}"
        [[ "$pat" == /* ]] && pat="${pat#/}"

        # Handle directory patterns (ending with /)
        if [[ "$pat" == */ ]]; then
            local dir_pattern="${pat%/}"
            if [[ "$rel_path" == "$dir_pattern"/* || "$rel_path" == "$dir_pattern" ]]; then
                debug "Path $rel_path matches directory pattern $pattern"
                return 0
            fi
        fi

        # Handle glob patterns
        if [[ "$rel_path" == $pat ]]; then
            debug "Path $rel_path matches pattern $pattern"
            return 0
        fi
    done
    return 1
}

# Check if file should be ignored
is_ignored() {
    local path="$1"
    
    # Always ignore the output file itself (default or custom -o)
    if [[ -n "$OUTPUT_ABS" ]]; then
        # Compare absolute paths; entries discovered by find are absolute
        if [[ "$path" == "$OUTPUT_ABS" ]]; then
            debug "Path $path is the output file; excluding"
            return 0
        fi
    fi

    # If include patterns are specified and the path matches one, do NOT ignore it.
    # This gives `-i` precedence over ignore rules.
    if [[ ${#INCLUDE_PATTERNS[@]} -gt 0 ]] && matches_pattern "$path" "${INCLUDE_PATTERNS[@]}"; then
        debug "Path $path is explicitly included, overriding ignore rules."
        return 1 # Not ignored (in Bash, 1 is a "false" exit code)
    fi

    # Check if path contains .git directory
    if [[ "$path" == *".git"* ]]; then
        debug "Path $path contains .git directory"
        return 0
    fi
    
    # Check against ignore patterns
    if matches_pattern "$path" "${ALL_IGNORE_PATTERNS[@]}"; then
        return 0
    fi
    
    # Check if file is binary
    if [[ -f "$path" ]] && is_binary "$path"; then
        return 0
    fi
    
    return 1
}

# Check if file should be included
is_included() {
    local path="$1"
    
    # If no include patterns specified, include all files
    if [[ ${#INCLUDE_PATTERNS[@]} -eq 0 ]]; then
        return 0
    fi
    
    matches_pattern "$path" "${INCLUDE_PATTERNS[@]}"
}

# Generate directory tree structure
generate_tree() {
    local dir="$1"
    local prefix="$2"
    
    # Get entries in directory and sort them
    local entries=()
    while IFS= read -r -d $'\0' entry; do
        if ! is_ignored "$entry" && is_included "$entry"; then
            entries+=("$entry")
        fi
    done < <(find "$dir" -maxdepth 1 -mindepth 1 -print0 | sort -z)
    
    local count=${#entries[@]}
    local i=0
    
    for entry in "${entries[@]}"; do
        i=$((i+1))
        local name=$(basename "$entry")
        local is_last=$((i == count))
        local new_prefix="$prefix"
        
        if [[ $is_last -eq 1 ]]; then
            echo "${prefix}└── $name"
            new_prefix="${prefix}    "
        else
            echo "${prefix}├── $name"
            new_prefix="${prefix}│   "
        fi
        
        if [[ -d "$entry" ]]; then
            generate_tree "$entry" "$new_prefix"
        fi
    done
}

# Create temporary files
TREE_FILE=$(mktemp)
CONTENT_FILE=$(mktemp)
COUNT_FILE=$(mktemp)
DEBUG_FILE=$(mktemp)

# Generate directory tree
echo "Directory structure:" > "$TREE_FILE"
echo "$(basename "$SOURCE_DIR")" >> "$TREE_FILE"
generate_tree "$SOURCE_DIR" "" >> "$TREE_FILE"

# Initialize counters
echo "0" > "$COUNT_FILE"  # Total files
echo "0" >> "$COUNT_FILE" # Total lines

# Process file contents
echo "File processing log:" > "$DEBUG_FILE"
find "$SOURCE_DIR" -type f -print0 | while IFS= read -r -d $'\0' file; do
    rel_path="${file#$SOURCE_DIR/}"
    
    if is_ignored "$file"; then
        echo "IGNORED: $rel_path" >> "$DEBUG_FILE"
        continue
    fi
    
    if ! is_included "$file"; then
        echo "NOT INCLUDED: $rel_path" >> "$DEBUG_FILE"
        continue
    fi
    
    echo "PROCESSING: $rel_path" >> "$DEBUG_FILE"
    
    # Count lines (handle potential errors)
    lines=$(wc -l < "$file" 2>/dev/null || echo "0")
    
    # Update counters
    file_count=$(head -n 1 "$COUNT_FILE")
    line_count=$(tail -n 1 "$COUNT_FILE")
    echo $((file_count + 1)) > "$COUNT_FILE"
    echo $((line_count + lines)) >> "$COUNT_FILE"
    
    # Add file content with proper encoding handling
    {
        echo "================================================"
        echo "FILE: $rel_path"
        echo "================================================"
        
        # Special handling for Jupyter notebooks
        if [[ "${file##*.}" == "ipynb" ]]; then
            if ! convert_ipynb_to_markdown "$file"; then
                # If conversion failed, just dump the raw content
                iconv -f UTF-8 -t UTF-8 -c "$file" 2>/dev/null || \
                iconv -f CP1252 -t UTF-8 -c "$file" 2>/dev/null || \
                iconv -f ISO-8859-1 -t UTF-8 -c "$file" 2>/dev/null || \
                cat "$file" 2>/dev/null
            fi
        else
            # Convert file content to UTF-8, removing any problematic characters
            iconv -f UTF-8 -t UTF-8 -c "$file" 2>/dev/null || \
            iconv -f CP1252 -t UTF-8 -c "$file" 2>/dev/null || \
            iconv -f ISO-8859-1 -t UTF-8 -c "$file" 2>/dev/null || \
            cat "$file" 2>/dev/null
        fi
        echo
    } >> "$CONTENT_FILE"
done

# Read final counts
FILE_COUNT=$(head -n 1 "$COUNT_FILE")
LINE_COUNT=$(tail -n 1 "$COUNT_FILE")

# Generate summary
SUMMARY="Summary:
--------
Total files: $FILE_COUNT
Total lines: $LINE_COUNT
Max file size: $MAX_FILE_SIZE bytes
"

# Output results
if [[ "$OUTPUT_FILE" == "-" ]]; then
    echo "$SUMMARY"
    cat "$TREE_FILE"
    echo
    cat "$CONTENT_FILE"
else
    {
        echo "$SUMMARY"
        cat "$TREE_FILE"
        echo
        cat "$CONTENT_FILE"
    } > "$OUTPUT_FILE"
    echo "Analysis complete! Output written to: $OUTPUT_FILE"
fi

# Show debug information if requested
if [[ "$DEBUG" == "true" ]]; then
    echo "Debug information:" >&2
    cat "$DEBUG_FILE" >&2
fi

# Clean up temporary files
rm -f "$TREE_FILE" "$CONTENT_FILE" "$COUNT_FILE" "$DEBUG_FILE"
</file>

<file path="dot_tmux.conf">
# Tmux configuration managed by chezmoi
# Place at ~/.local/share/chezmoi/dot_tmux.conf

# Basic tmux configuration
set -g default-terminal "screen-256color"
set -g mouse on
set -g base-index 1
setw -g pane-base-index 1
set-option -g default-shell /home/linuxbrew/.linuxbrew/bin/fish


# Set prefix to Ctrl+b (default, but explicitly set)
set -g prefix C-b
unbind C-b

# Automatic window renaming based on current directory
set -g automatic-rename on
set -g automatic-rename-format "#{b:pane_current_path}"

# Enable true color support
set -ga terminal-overrides ",*256col*:Tc"

# History limit
set -g history-limit 50000

# Reduce escape key delay
set -sg escape-time 10

# Enable activity monitoring
setw -g monitor-activity on
set -g visual-activity on

# Pane splitting
unbind '"'
unbind %
bind | split-window -h
bind - split-window -v

# Window navigation
bind r source-file ~/.tmux.conf \; display "Reloaded!"

# Pane navigation
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R

# Pane resizing
bind -r H resize-pane -L 5
bind -r J resize-pane -D 5
bind -r K resize-pane -U 5
bind -r L resize-pane -R 5

# Copy mode settings
setw -g mode-keys vi
bind p paste-buffer

# TPM plugins
set -g @plugin 'tmux-plugins/tpm'
set -g @plugin 'tmux-plugins/tmux-sensible'
set -g @plugin 'tmux-plugins/tmux-yank'
set -g @plugin 'tmux-plugins/tmux-resurrect'
set -g @plugin 'tmux-plugins/tmux-continuum'
set -g @plugin 'catppuccin/tmux#v2.1.3'
set -g @plugin 'jaclu/tmux-menus'

#tmux-menus
set -g @menus_trigger 'Space'

set -g @catppuccin_flavor 'mocha'
set -g @catppuccin_window_status_style "basic"

# tmux-resurrect settings
set -g @resurrect-capture-pane-contents 'on'
set -g @resurrect-save-bash-history 'on'
set -g @resurrect-strategy-nvim 'session'

# tmux-continuum settings
set -g @continuum-restore 'on'
set -g @continuum-save-interval '15'

# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
if "test ! -d ~/.tmux/plugins/tpm" \
   "run 'git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm && ~/.tmux/plugins/tpm/bin/install_plugins'"
run '~/.tmux/plugins/tpm/tpm'
</file>

<file path="pwsh/install_wsl/Modules/WSL-Command.psm1">
# ============================================================================
# WSL Command Execution Module
# ============================================================================

<#
.SYNOPSIS
    Provides WSL command execution functions.

.DESCRIPTION
    This module contains functions for executing commands in WSL distributions
    both programmatically and interactively.

.PARAMETER Parameters
    Hashtable containing script parameters and configuration values.
#>

# Accept parameters from the main script
param(
    [Parameter(Mandatory)]
    [hashtable]$Parameters
)

# Extract parameters from the hashtable
$script:Debug = $Parameters.Debug
$script:DefaultDistro = $Parameters.DefaultDistro
$script:DefaultName = $Parameters.DefaultName
$script:DefaultUsername = $Parameters.DefaultUsername
$script:PackageManagerPackages = $Parameters.PackageManagerPackages
$script:DistributionReadyMaxAttempts = $Parameters.DistributionReadyMaxAttempts
$script:DistributionReadyDelaySeconds = $Parameters.DistributionReadyDelaySeconds

# ============================================================================
# WSL Command Execution Functions
# ============================================================================

function Invoke-WSLCommand {
    <#
    .SYNOPSIS
        Executes a command in a WSL distribution.
    .DESCRIPTION
        Runs a bash command in the specified WSL distribution as a specified user.
        Provides consistent output handling and error checking.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER Command
        The command to execute.
    .PARAMETER Username
        The username to run as. Defaults to 'root' if AsRoot is specified.
    .PARAMETER AsRoot
        Run the command as root user.
    .PARAMETER Quiet
        Suppress command output.
    .OUTPUTS
        [string] Command output if not in quiet mode.
    #>
    [CmdletBinding()]
    [OutputType([string])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Command,
        
        [string]$Username,
        
        [switch]$AsRoot,
        
        [switch]$Quiet
    )
    
    # Determine user
    $User = if ($AsRoot) { "root" } elseif ($Username) { $Username } else { "root" }
    
    Write-LogMessage "Executing in WSL '$DistroName' as '$User': $Command" -Level Debug
    
    $WslArgs = @("--distribution", $DistroName, "--user", $User, "--", "bash", "-c", $Command)
    
    try {
        # Execute WSL command and capture output
        $Output = & wsl @WslArgs 2>&1 | Out-String

        # Format output based on mode (debug/quiet/normal)
        return Format-WSLOutput -Output $Output -Debug:$script:Debug -Quiet:$Quiet
    }
    catch {
        Write-LogMessage "WSL command failed: $($_.Exception.Message.Trim())" -Level Error
        throw
    }
}

function Invoke-WSLCommandInteractive {
    <#
    .SYNOPSIS
        Opens a new Windows Terminal window for interactive WSL commands.
    .DESCRIPTION
        Launches Windows Terminal with the specified command and waits for completion.
        Used for interactive operations like Chezmoi setup.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER Command
        The command to execute.
    .PARAMETER Username
        The username to run as (defaults to root).
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Command,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Username
    )
    
    # Check if the distribution exists
    if (-not (Test-DistributionExists -DistroName $DistroName)) {
        throw "WSL distribution '$DistroName' does not exist or is not available"
    }
    
    $WtPath = Join-Path $env:LOCALAPPDATA "Microsoft\WindowsApps\wt.exe"
    
    if (-not (Test-Path $WtPath)) {
        throw "Windows Terminal not found at: $WtPath"
    }
    
    $StartInfo = @{
        FilePath     = "alacritty"
        ArgumentList = @("-e", "wsl -d $DistroName --user $Username --exec $Command")
        Wait         = $true
    }
    
    Write-LogMessage "Starting Windows Terminal process" -Level Info
    Start-Process -FilePath "alacritty" -ArgumentList "-e wsl -d $DistroName -u $Username -- bash -i -c '$Command;bash'" -Wait
    #Write-LogMessage "Start-Process -FilePath `"alacritty`" -ArgumentList `"-e wsl -d $DistroName -u $Username sh -c $Command`" -Wait" -Level Debug
}

# Export functions
Export-ModuleMember -Function Invoke-WSLCommand, Invoke-WSLCommandInteractive
</file>

<file path="pwsh/install_wsl/Modules/WSL-UserManagement.psm1">
# ============================================================================
# WSL User Management Module
# ============================================================================

<#
.SYNOPSIS
    Provides user management functions for WSL distributions.

.DESCRIPTION
    This module contains functions for creating users, configuring sudo access,
    and testing user configurations.

.PARAMETER Parameters
    Hashtable containing script parameters and configuration values.
#>

# Accept parameters from the main script
param(
    [Parameter(Mandatory)]
    [hashtable]$Parameters
)

# Extract parameters from the hashtable
$script:Debug = $Parameters.Debug
$script:DefaultDistro = $Parameters.DefaultDistro
$script:DefaultName = $Parameters.DefaultName
$script:DefaultUsername = $Parameters.DefaultUsername
$script:PackageManagerPackages = $Parameters.PackageManagerPackages
$script:DistributionReadyMaxAttempts = $Parameters.DistributionReadyMaxAttempts
$script:DistributionReadyDelaySeconds = $Parameters.DistributionReadyDelaySeconds

# ============================================================================
# User Management Functions
# ============================================================================

function New-WSLUser {
    <#
    .SYNOPSIS
        Creates a new user in the WSL distribution.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER Username
        The username to create.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Username
    )
    
    Write-Section "Creating WSL User"
    
    try {
        # Create user
        Write-LogMessage "Creating user: $Username" -Level Info
        $Command = "useradd -m -s /bin/bash $Username"
        Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot -Quiet
        
        # Verify user creation
        $Command = "id $Username"
        Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot -Quiet
        
        Write-LogMessage "User created successfully: $Username" -Level Success
    }
    catch {
        Write-LogMessage "Failed to create user: $($_.Exception.Message.Trim())" -Level Error
        throw
    }
}

function Add-UserToSudoers {
    <#
    .SYNOPSIS
        Adds user to sudoers with passwordless sudo.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER Username
        The username to configure.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Username
    )
    
    Write-Section "Configuring Sudo Access"
    
    try {
        # Add user to wheel group
        Write-LogMessage "Adding user to wheel group..." -Level Info
        $Command = "usermod -aG wheel $Username"
        Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot -Quiet
        
        # Configure passwordless sudo for wheel group
        Write-LogMessage "Configuring passwordless sudo..." -Level Info
        $Command = "echo '%wheel ALL=(ALL:ALL) NOPASSWD: ALL' >> /etc/sudoers.d/wheel && chmod 440 /etc/sudoers.d/wheel"
        Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot -Quiet
        

        # Configure systemd
        Write-LogMessage "Configuring systemd" -Level Info
        $systemD= "[boot]`nsystemd=true`n`n[user]`ndefault=$username`n`n"
        $Command = "echo '$systemD' | sudo tee /etc/wsl.conf > /dev/null"
        Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot -Quiet

        $Command = "sudo chown ${Username}:wheel -R /run/user/1000"
        Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot -Quiet
        # Verify sudo access
        Write-LogMessage "Verifying sudo access..." -Level Info
        Start-Sleep -Seconds 2
        
        if (Test-UserSudoAccess -DistroName $DistroName -Username $Username) {
            Write-LogMessage "Sudo access configured and verified successfully" -Level Success
        }
        else {
            Write-LogMessage "Sudo access configured but verification failed" -Level Warning
            Write-LogMessage "You may need to restart the WSL distribution" -Level Warning
        }
    }
    catch {
        Write-LogMessage "Failed to configure sudo access: $($_.Exception.Message.Trim())" -Level Error
        throw
    }
}

function Test-Configuration {
    <#
    .SYNOPSIS
        Tests the WSL configuration to ensure it is correct.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER Username
        The username to test.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Username
    )
    
    Write-Section "Testing Configuration"
    
    try {
        # Test user ID
        Write-LogMessage "Testing user information..." -Level Info
        $Command = "id $Username"
        Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot -Quiet
        
        # Test user groups
        Write-LogMessage "Testing user groups..." -Level Info
        $Command = "groups $Username"
        Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot -Quiet
        
        # Test sudo access
        if (-not (Test-UserSudoAccess -DistroName $DistroName -Username $Username)) {
            Write-LogMessage "Warning: Sudo configuration may not be working properly" -Level Warning
        }
        else {
            Write-LogMessage "Sudo access verified" -Level Success
        }
        
        Write-LogMessage "Configuration testing complete" -Level Success
    }
    catch {
        Write-LogMessage "Configuration testing failed: $($_.Exception.Message.Trim())" -Level Warning
    }
}

# Export functions
Export-ModuleMember -Function New-WSLUser, Add-UserToSudoers, Test-Configuration
</file>

<file path="dot_aliases">
alias ls='eza --all --long --group --group-directories-first --icons --header --time-style long-iso'
alias tree='eza --tree'
alias cat='bat'
alias grep='rg'
alias please="sudo !!"
alias pacman="sudo pacman --noconfirm"
alias config="cd ~/.config"
alias dotfiles="chezmoi cd"
alias chezmoi-update="chezmoi update && exec fish"
alias lg="lazygit"

function gobuild
    mkdir -p "$HOME/.local/bin"
    go build -o "$HOME/.local/bin/"
end
</file>

<file path="dot_gitconfig.tmpl">
# Example configuration file using user data
# This file demonstrates how to use the interactive prompt data

# Git configuration using prompted data
{{- if eq .chezmoi.os "linux" }}
[user]
    name = {{ .github_user | quote }}
    email = {{ .github_email | quote }}

[github]
    user = {{ .github_user | quote }}
{{- end }}

[core]
    editor = nano
    autocrlf = input

[init]
    defaultBranch = main

[include]
    path = ~/.config/git/alias
</file>

<file path="pwsh/install_wsl/Modules/WSL-SSH.psm1">
# ============================================================================
# WSL SSH Module
# ============================================================================

<#
.SYNOPSIS
    Provides SSH configuration functions for WSL distributions.

.DESCRIPTION
    This module contains functions for configuring SSH port forwarding,
    managing firewall rules, and testing SSH services.

.PARAMETER Parameters
    Hashtable containing script parameters and configuration values.
#>

# Accept parameters from the main script
param(
    [Parameter(Mandatory)]
    [hashtable]$Parameters
)

# Extract parameters from the hashtable
$script:Debug = $Parameters.Debug
$script:DefaultDistro = $Parameters.DefaultDistro
$script:DefaultName = $Parameters.DefaultName
$script:DefaultUsername = $Parameters.DefaultUsername
$script:PackageManagerPackages = $Parameters.PackageManagerPackages
$script:DistributionReadyMaxAttempts = $Parameters.DistributionReadyMaxAttempts
$script:DistributionReadyDelaySeconds = $Parameters.DistributionReadyDelaySeconds

# ============================================================================
# SSH Functions
# ============================================================================

function Test-SSHDRunning {
    <#
    .SYNOPSIS
        Checks if sshd is running in the WSL distribution.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .OUTPUTS
        [bool] True if sshd is running, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    try {
        $Command = "systemctl is-active sshd 2>/dev/null || service ssh status 2>/dev/null"
        $Result = Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot
        return $Result -match "active|running"
    }
    catch {
        return $false
    }
}

function Get-SSHDPort {
    <#
    .SYNOPSIS
        Retrieves the SSH port from sshd configuration.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .OUTPUTS
        [int] The SSH port number (defaults to 22).
    #>
    [CmdletBinding()]
    [OutputType([int])]
    param(
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )

    try {
        # Try multiple methods to get the SSH port
        $Commands = @(
            # Method 1: Use sed to extract Port line and get the number
            "sed -n 's/^Port\s\+\([0-9]\+\).*/\1/p' /etc/ssh/sshd_config 2>/dev/null | head -n1",
            # Method 2: Use grep and awk (fixed escaping)
            "grep '^Port\>' /etc/ssh/sshd_config 2>/dev/null | awk '{print \$2}' | head -n1",
            # Method 3: Use awk directly
            "awk '/^Port\>/ {print \$2; exit}' /etc/ssh/sshd_config 2>/dev/null"
        )

        foreach ($Cmd in $Commands) {
            try {
                $Result = Invoke-WSLCommand -DistroName $DistroName -Command $Cmd -AsRoot

                if ($null -ne $Result -and $Result.Trim() -ne '') {
                    $PortString = $Result.Trim()

                    # Remove any additional whitespace or newlines
                    $PortString = ($PortString -split '[\r\n\s]+' | Select-Object -First 1).Trim()

                    if ($PortString -match '^\d+$') {
                        $Port = [int]$PortString
                        Write-LogMessage "Successfully retrieved SSH port: $Port" -Level Debug
                        return $Port
                    }
                }
            }
            catch {
                Write-LogMessage "SSH port detection method failed: $($_.Exception.Message.Trim())" -Level Debug
                continue
            }
        }

        # If all methods fail, try to get default port by checking if sshd is running on default port
        Write-LogMessage "Could not extract SSH port from config, checking if default port 22 is in use" -Level Debug
        $DefaultPortCheck = "ss -tlnp 2>/dev/null | grep ':22\s'"
        $DefaultPortResult = Invoke-WSLCommand -DistroName $DistroName -Command $DefaultPortCheck -AsRoot

        if ($null -ne $DefaultPortResult -and $DefaultPortResult.Trim() -ne '') {
            Write-LogMessage "SSH daemon appears to be running on default port 22" -Level Debug
            return 22
        }

        # Default SSH port if nothing else works
        Write-LogMessage "Using default SSH port 22 (could not determine from config)" -Level Warning
        return 22
    }
    catch {
        Write-LogMessage "Error retrieving SSH port: $($_.Exception.Message.Trim())" -Level Warning
        return 22
    }
}

function Get-WSLIPAddress {
    <#
    .SYNOPSIS
        Retrieves the IP address of a WSL distribution.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .OUTPUTS
        [string] The IP address of the distribution.
    #>
    [CmdletBinding()]
    [OutputType([string])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    # Try multiple methods to get the WSL IP address
    $Methods = @(
        # Method 1: hostname -I (may not be available in all distributions)
        "hostname -I 2>/dev/null | awk '{print `$1}'",
        # Method 2: ip command to get eth0 address
        "ip -4 addr show eth0 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -n1",
        # Method 3: ip command with full path
        "/sbin/ip -4 addr show eth0 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -n1",
        # Method 4: Try all interfaces
        "ip -4 addr show 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | grep -v '127.0.0.1' | head -n1"
    )
    
    foreach ($Method in $Methods) {
        try {
            $WslIpOutput = Invoke-WSLCommand -DistroName $DistroName -Command $Method -AsRoot
            $WslIp = $WslIpOutput.Trim()
            
            # Validate IP address format
            if ($WslIp -match '^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$') {
                Write-LogMessage "Found WSL IP address using method: $Method" -Level Debug
                Write-LogMessage "IP Address: $WslIp" -Level Debug
                return $WslIp
            }
        }
        catch {
            Write-LogMessage "IP detection method failed: $Method" -Level Debug
            continue
        }
    }
    
    throw "Could not retrieve WSL IP address using any available method. Make sure the distribution is running and has network connectivity."
}

function New-SSHPortForward {
    <#
    .SYNOPSIS
        Creates SSH port forwarding from Windows host to WSL distribution.
    .DESCRIPTION
        Sets up port forwarding by getting the WSL IP address and creating a netsh
        port proxy rule to forward traffic from a Windows host port to the WSL SSH port.
    .PARAMETER Port
        The external port on Windows host to forward from.
    .PARAMETER DistroName
        The name of the WSL distribution to forward to.
    .PARAMETER ListenAddress
        The IP address to listen on (default: 0.0.0.0).
    .PARAMETER ConnectPort
        The SSH port inside WSL (default: same as Port).
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateRange(1, 65535)]
        [int]$Port,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [string]$ListenAddress = "0.0.0.0",
        
        [int]$ConnectPort = $Port
    )
    
    Write-LogMessage "Getting WSL IP address for distribution: $DistroName" -Level Info
    
    try {
        $WslIp = Get-WSLIPAddress -DistroName $DistroName
        Write-LogMessage "WSL IP address: $WslIp" -Level Info
        
        # Remove existing port proxy rule (if any)
        Write-LogMessage "Removing existing port proxy rule for port $Port..." -Level Info
        $null = netsh interface portproxy delete v4tov4 listenport=$Port listenaddress=$ListenAddress 2>$null
        
        # Add new port proxy rule
        Write-LogMessage "Adding new port proxy rule..." -Level Info
        $AddResult = netsh interface portproxy add v4tov4 listenaddress=$ListenAddress listenport=$Port connectaddress=$WslIp connectport=$ConnectPort
        
        if ($LASTEXITCODE -eq 0) {
            Write-LogMessage "SSH port forwarding created successfully" -Level Success
            Write-LogMessage "Windows host port $Port now forwards to ${DistroName}:$ConnectPort" -Level Info
        }
        else {
            throw "Failed to create port forwarding rule. Error: $AddResult"
        }
    }
    catch {
        Write-LogMessage "Failed to create SSH port forwarding: $($_.Exception.Message.Trim())" -Level Error
        throw
    }
}

function New-SSHFirewallRule {
    <#
    .SYNOPSIS
        Creates a Windows Firewall rule for SSH port forwarding.
    .PARAMETER Port
        The port to create firewall rule for.
    .PARAMETER DistroName
        The name of the WSL distribution (used in rule name).
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateRange(1, 65535)]
        [int]$Port,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    $RuleName = "WSL-$DistroName-SSH-$Port"
    
    try {
        # Check if rule already exists
        $ExistingRule = Get-NetFirewallRule -DisplayName $RuleName -ErrorAction SilentlyContinue
        
        if ($ExistingRule) {
            Write-LogMessage "Firewall rule '$RuleName' already exists" -Level Info
            return
        }
        
        # Create new firewall rule
        $null = New-NetFirewallRule -DisplayName $RuleName `
            -Direction Inbound `
            -Action Allow `
            -Protocol TCP `
            -LocalPort $Port `
            -Profile Any `
            -Description "SSH access for WSL distribution: $DistroName"
        
        Write-LogMessage "Created firewall rule '$RuleName' for port $Port" -Level Success
    }
    catch {
        Write-LogMessage "Failed to create firewall rule: $($_.Exception.Message.Trim())" -Level Error
        throw
    }
}

function Invoke-SSHConfiguration {
    <#
    .SYNOPSIS
        Configures SSH port forwarding and firewall rules.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER UseDefaults
        Whether to skip prompts and use defaults.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [switch]$UseDefaults
    )
    
    Write-Section "SSH Port Forwarding Configuration"
    
    $ConfigureSSH = $false

    $Response = Read-Host "Configure SSH Port Forwarding? (Y/n)"
    $ConfigureSSH = -not ($Response -eq 'n' -or $Response -eq 'N')
    
    if (-not $ConfigureSSH) {
        return
    }
    
    Start-Sleep 5
    # Verify sshd is running
    if (-not (Test-SSHDRunning -DistroName $DistroName)) {
        Write-LogMessage "sshd is not running in WSL distribution" -Level Warning
        $StartSSHD = Read-Host "Would you like to start sshd? (Y/n)"
        
        if (-not ($StartSSHD -eq 'n' -or $StartSSHD -eq 'N')) {
            try {
                $Command = "systemctl start sshd || service ssh start"
                Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot -Quiet
                Start-Sleep -Seconds 2
                
                if (-not (Test-SSHDRunning -DistroName $DistroName)) {
                    Write-LogMessage "Failed to start sshd - configuration skipped" -Level Warning
                    return
                }
            }
            catch {
                Write-LogMessage "Failed to start sshd: $($_.Exception.Message.Trim())" -Level Error
                return
            }
        }
        else {
            Write-LogMessage "SSH configuration skipped - sshd not running" -Level Warning
            return
        }
    }
    
    # Get SSH port and configure forwarding
    try {
        $SshPort = Get-SSHDPort -DistroName $DistroName
        Write-LogMessage "Detected SSH port: $SshPort" -Level Info
        
        New-SSHPortForward -Port $SshPort -DistroName $DistroName
        New-SSHFirewallRule -Port $SshPort -DistroName $DistroName
    }
    catch {
        Write-LogMessage "SSH configuration failed: $($_.Exception.Message.Trim())" -Level Warning
    }
}

# Export functions
Export-ModuleMember -Function Test-SSHDRunning, Get-SSHDPort, Get-WSLIPAddress, 
                              New-SSHPortForward, New-SSHFirewallRule, Invoke-SSHConfiguration
</file>

<file path=".chezmoiscripts/run_onchange_before_00_install_packages.sh.tmpl">
#!{{ lookPath "bash" }}
set -uo pipefail

# Source common functions
source "{{ .chezmoi.sourceDir }}/.chezmoiscripts/common.sh"

# Install package on Arch Linux using pacman
install_pacman_package() {
    local package="$1"
    
    if ! command_exists pacman; then
        log_error "Not an Arch-based system"
        return 1
    fi
    
    if pacman -Qi "$package" &>/dev/null; then
        log_info "$package is already installed"
        return 0
    fi
    
    log_info "Installing $package..."
    if sudo pacman -S --noconfirm --needed "$package" >/dev/null 2>&1; then
        log_success "Installed $package"
        return 0
    else
        log_error "Failed to install $package"
        return 1
    fi
}

# Install package on Termux
install_termux_package() {
    local package="$1"
    
    if ! command_exists pkg; then
        log_error "Not a Termux system"
        return 1
    fi
    
    if pkg list-installed 2>/dev/null | grep -q "^$package/"; then
        log_info "$package is already installed"
        return 0
    fi
    
    log_info "Installing $package..."
    if pkg install -y "$package" >/dev/null 2>&1; then
        log_success "Installed $package"
        return 0
    else
        log_error "Failed to install $package"
        return 1
    fi
}

# Install package using Homebrew
install_homebrew_package() {
    local package="$1"
    
    if brew list "$package" &>/dev/null; then
        log_info "$package is already installed"
        return 0
    fi
    
    log_info "Installing $package..."
    if brew install "$package" >/dev/null 2>&1; then
        log_success "Installed $package"
        return 0
    else
        log_error "Failed to install $package"
        return 1
    fi
}

# Install package using Homebrew (Cask)
install_homebrew_cask_package() {
    local package="$1"
    
    if brew list "$package" &>/dev/null; then
        log_info "$package is already installed"
        return 0
    fi
    
    log_info "Installing $package..."
    if brew install "$package" >/dev/null 2>&1; then
        log_success "Installed $package"
        return 0
    else
        log_error "Failed to install $package"
        return 1
    fi
}

# Install package using npm
install_npm_package() {
    local package="$1"
    
    if npm list -g "$package" &>/dev/null; then
        log_info "$package is already installed"
        return 0
    fi
    
    log_info "Installing $package..."
    if npm install -g "$package" >/dev/null 2>&1; then
        log_success "Installed $package"
        return 0
    else
        log_error "Failed to install $package"
        return 1
    fi
}

# Initialize Arch Linux packages
init_arch_packages() {
    if ! is_arch; then
        log_info "Not an Arch Linux system, skipping Arch packages"
        return 0
    fi
    
    local overall_success=true
    
    # Pacman packages
    if ! command_exists pacman; then
        log_error "Pacman not available"
        return 1
    fi
    
    {{- if .packages.linux.arch.pacman }}
    log_info "Installing Pacman packages..."
    local failed_packages=()
    
    {{- range .packages.linux.arch.pacman }}
    if ! install_pacman_package {{ . | quote }}; then
        failed_packages+=({{ . | quote }})
    fi
    {{- end }}
    
    if [[ ${#failed_packages[@]} -gt 0 ]]; then
        log_warning "Failed to install some Pacman packages:"
        for pkg in "${failed_packages[@]}"; do
            log_warning "  - $pkg"
        done
        overall_success=false
    fi
    {{- end }}
    
    # Homebrew installation
    if ! command_exists brew; then
        log_info "Installing Homebrew..."
        if ! install_homebrew; then
            log_error "Homebrew installation failed"
            log_warning "Skipping Homebrew packages"
            overall_success=false
            # Don't return - continue with other package managers
        fi
    fi
    
    # Homebrew packages
    if command_exists brew; then
        {{- if .packages.linux.arch.brew }}
        log_info "Installing Homebrew packages..."
        local failed_packages=()
        
        {{- range .packages.linux.arch.brew }}
        if ! install_homebrew_package {{ . | quote }}; then
            failed_packages+=({{ . | quote }})
        fi
        {{- end }}
        
        if [[ ${#failed_packages[@]} -gt 0 ]]; then
            log_warning "Failed to install some Homebrew packages:"
            for pkg in "${failed_packages[@]}"; do
                log_warning "  - $pkg"
            done
            overall_success=false
        fi
        {{- end }}
        
        {{- if .packages.linux.arch.casks }}
        log_info "Installing Homebrew casks..."
        local failed_packages=()
        
        {{- range .packages.linux.arch.casks }}
        if ! install_homebrew_cask_package {{ . | quote }}; then
            failed_packages+=({{ . | quote }})
        fi
        {{- end }}
        
        if [[ ${#failed_packages[@]} -gt 0 ]]; then
            log_warning "Failed to install some casks:"
            for pkg in "${failed_packages[@]}"; do
                log_warning "  - $pkg"
            done
            overall_success=false
        fi
        {{- end }}
    fi
    
    # NPM installation
    if ! command_exists npm; then
        log_info "Installing npm..."
        if ! install_npm; then
            log_error "npm installation failed"
            log_warning "Skipping npm packages"
            overall_success=false
            # Don't return - continue
        fi
    fi
    
    # NPM packages
    if command_exists npm; then
        {{- if .packages.linux.arch.npm }}
        log_info "Installing npm packages..."
        local failed_packages=()
        
        {{- range .packages.linux.arch.npm }}
        if ! install_npm_package {{ . | quote }}; then
            failed_packages+=({{ . | quote }})
        fi
        {{- end }}
        
        if [[ ${#failed_packages[@]} -gt 0 ]]; then
            log_warning "Failed to install some npm packages:"
            for pkg in "${failed_packages[@]}"; do
                log_warning "  - $pkg"
            done
            overall_success=false
        fi
        {{- end }}
    fi
    
    if [[ "$overall_success" == true ]]; then
        return 0
    else
        log_warning "Some package installations failed"
        return 1
    fi
}

# Initialize Android/Termux packages
init_android_packages() {
    if ! is_android; then
        log_info "Not an Android system, skipping Termux packages"
        return 0
    fi
    
    if ! command_exists pkg; then
        log_error "pkg not available"
        return 1
    fi
    
    export DEBIAN_FRONTEND=noninteractive
    
    # Setup storage and repository
    log_info "Setting up Termux environment..."

# Check if storage is already set up
if [[ ! -d "$HOME/storage" ]]; then
    log_info "Setting up Termux storage (may require user interaction)..."
    if termux-setup-storage; then
        log_success "Termux storage configured successfully"
    else
        log_warning "Storage setup failed or was cancelled"
    fi
else
    log_success "Termux storage already configured"
fi

if termux-change-repo 2>/dev/null; then
    log_success "Termux repository configured"
else
    log_warning "termux-change-repo failed (may already be configured)"
fi
    
    {{- if .packages.android.termux }}
    log_info "Updating pkg repo & upgrading..."
    if ! pkg update -y >/dev/null 2>&1; then
        log_error "pkg update failed"
        return 1
    fi
    
    if ! pkg upgrade -y >/dev/null 2>&1; then
        log_warning "pkg upgrade had issues (continuing anyway)"
    fi

    log_info "Installing Termux packages..."
    local failed_packages=()
    
    {{- range .packages.android.termux.pkg }}
    if ! install_termux_package {{ . | quote }}; then
        failed_packages+=({{ . | quote }})
    fi
    {{- end }}

    log_info "Cleaning pkg..."
    pkg clean >/dev/null 2>&1 || log_warning "pkg clean had issues"
    pkg autoclean >/dev/null 2>&1 || log_warning "pkg autoclean had issues"
    
    if [[ ${#failed_packages[@]} -gt 0 ]]; then
        log_warning "Failed to install some Termux packages:"
        for pkg in "${failed_packages[@]}"; do
            log_warning "  - $pkg"
        done
        return 1
    fi
    {{- else }}
    log_info "No Termux packages defined in configuration"
    {{- end }}
    
    return 0
}

main() {
    log_header "Installing Packages"
    
    local install_success=true
    
    # Initialize packages based on platform
    if is_arch; then
        if ! init_arch_packages; then
            log_warning "Arch package installation had some failures"
            install_success=false
        fi
    elif is_android; then
        if ! init_android_packages; then
            log_warning "Android package installation had some failures"
            install_success=false
        fi
    else
        log_warning "Unknown platform, skipping package installation"
        return 0
    fi
    
    # Handle WSL-specific installation (WSL can also be Arch-based)
    if is_wsl; then
        log_info "Detected WSL environment"
        
        # Check if wslu is already installed
        if command_exists wslu; then
            log_info "WSLU is already installed"
        else
            log_info "Installing WSLU..."
            if curl -fsSL https://raw.githubusercontent.com/wslutilities/wslu/master/extras/scripts/wslu-install 2>/dev/null | bash; then
                log_success "WSLU installed successfully"
            else
                log_error "Failed to install WSLU"
                log_warning "Continuing despite WSLU failure"
                install_success=false
            fi
        fi
    fi

    if [[ "$install_success" == true ]]; then
        log_success "Package installation completed successfully"
        return 0
    else
        log_warning "Package installation completed with some failures"
        log_info "Review the warnings above for details"
        return 1
    fi
}

main "$@"
</file>

<file path="pwsh/install_wsl/Modules/WSL-Validation.psm1">
# ============================================================================
# WSL Validation Module
# ============================================================================

<#
.SYNOPSIS
    Provides validation functions for WSL installation scripts.

.DESCRIPTION
    This module contains functions for validating usernames, checking
    system availability, and testing WSL distribution status.

.PARAMETER Parameters
    Hashtable containing script parameters and configuration values.
#>

# Accept parameters from the main script
param(
    [Parameter(Mandatory)]
    [hashtable]$Parameters
)

# Extract parameters from the hashtable
$script:Debug = $Parameters.Debug
$script:DefaultDistro = $Parameters.DefaultDistro
$script:DefaultName = $Parameters.DefaultName
$script:DefaultUsername = $Parameters.DefaultUsername
$script:PackageManagerPackages = $Parameters.PackageManagerPackages
$script:DistributionReadyMaxAttempts = $Parameters.DistributionReadyMaxAttempts
$script:DistributionReadyDelaySeconds = $Parameters.DistributionReadyDelaySeconds

# ============================================================================
# Validation Functions
# ============================================================================

function Test-ValidLinuxUsername {
    <#
    .SYNOPSIS
        Validates that a username meets Linux requirements.
    .DESCRIPTION
        Checks if username starts with lowercase letter or underscore,
        contains only valid characters, and is within length limits.
    .PARAMETER Username
        The username to validate.
    .OUTPUTS
        [bool] True if valid, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [string]$Username
    )
    
    # Linux username requirements: lowercase letters, numbers, underscore, hyphen
    # Must start with lowercase letter or underscore
    # Max 32 characters
    if ($Username -notmatch '^[a-z_][a-z0-9_-]{0,31}$') {
        return $false
    }
    
    return $true
}

function Test-GitAvailable {
    <#
    .SYNOPSIS
        Checks if git is available in the system PATH.
    .OUTPUTS
        [bool] True if git is available, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param()
    
    try {
        $null = Get-Command git -ErrorAction Stop
        return $true
    }
    catch {
        return $false
    }
}

function Test-DistributionExists {
    <#
    .SYNOPSIS
        Checks if a WSL distribution exists.
    .PARAMETER DistroName
        The name of the distribution to check.
    .OUTPUTS
        [bool] True if distribution exists, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    Write-LogMessage "Checking if WSL distribution '$DistroName' exists" -Level Debug
    
    try {
        $Distributions = wsl --list --quiet 2>$null | Out-String
        
        if (-not [string]::IsNullOrWhiteSpace($Distributions)) {
            $DistributionList = $Distributions -split "`r?`n" | Where-Object { $_ -and $_.Trim() }
            
            foreach ($Distro in $DistributionList) {
                $CleanDistro = Format-WSLOutput -Output $Distro
                
                if ($CleanDistro -eq $DistroName) {
                    Write-LogMessage "Distribution '$DistroName' exists" -Level Debug
                    return $true
                }
            }
        }
        
        Write-LogMessage "Distribution '$DistroName' does not exist" -Level Debug
        return $false
    }
    catch {
        Write-LogMessage "Error checking if distribution exists: $($_.Exception.Message.Trim())" -Level Error
        return $false
    }
}

function Test-DistributionReady {
    <#
    .SYNOPSIS
        Tests if a WSL distribution is ready for commands.
    .PARAMETER DistroName
        The name of the distribution to test.
    .OUTPUTS
        [bool] True if ready, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    # Pre-condition validation: Check if distribution exists first
    if (-not (Test-DistributionExists -DistroName $DistroName)) {
        Write-LogMessage "Cannot test readiness - distribution '$DistroName' does not exist" -Level Warning
        return $false
    }
    
    try {
        $Result = wsl -d $DistroName -u root -- echo "ready" 2>&1 | Out-String
        
        # Ensure we return a boolean value
        if ([string]::IsNullOrWhiteSpace($Result)) {
            return $false
        }
        
        return $Result -match "ready"
    }
    catch {
        return $false
    }
}

function Test-UserExists {
    <#
    .SYNOPSIS
        Checks if a user exists in the WSL distribution.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER Username
        The username to check.
    .OUTPUTS
        [bool] True if user exists, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Username
    )
    
    # Pre-condition validation: Check if distribution exists first
    if (-not (Test-DistributionExists -DistroName $DistroName)) {
        Write-LogMessage "Cannot check user '$Username' - distribution '$DistroName' does not exist" -Level Warning
        return $false
    }
    
    try {
        $Command = "id $Username >/dev/null 2>&1 && echo 'exists' || echo 'not_found'"
        $Result = Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot
        
        # Ensure we return a boolean value
        if ([string]::IsNullOrWhiteSpace($Result)) {
            return $false
        }
        
        return $Result -match "exists"
    }
    catch {
        Write-LogMessage "Error checking if user exists: $($_.Exception.Message.Trim())" -Level Warning
        return $false
    }
}

function Test-UserSudoAccess {
    <#
    .SYNOPSIS
        Tests if a user can use sudo without password prompts.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER Username
        The username to test.
    .OUTPUTS
        [bool] True if user has passwordless sudo, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Username
    )
    
    # Pre-condition validation: Check if distribution exists and user exists first
    if (-not (Test-DistributionExists -DistroName $DistroName)) {
        Write-LogMessage "Cannot check sudo access for user '$Username' - distribution '$DistroName' does not exist" -Level Warning
        return $false
    }
    
    if (-not (Test-UserExists -DistroName $DistroName -Username $Username)) {
        Write-LogMessage "Cannot check sudo access - user '$Username' does not exist in distribution '$DistroName'" -Level Warning
        return $false
    }
    
    try {
        $Command = "sudo -n whoami"
        Invoke-WSLCommand -DistroName $DistroName -Command $Command -Username $Username
        return ($LASTEXITCODE -eq 0)
    }
    catch {
        return $false
    }
}

function Test-PacmanKeyInitialized {
    <#
    .SYNOPSIS
        Uses pacman-key to test if the pacman keyring is initialized for a WSL distribution.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .OUTPUTS
        [bool] True if initialized, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )

    if (-not (Test-DistributionExists -DistroName $DistroName)) {
        Write-LogMessage "Distro '$DistroName' does not exist; skipping pacman-key initialization check." -Level Warning
        return $false
    }

    try {
        # Use pacman-key to list keys and check if the keyring is initialized
        $Command = "pacman-key --list-keys >/dev/null 2>&1 && echo 'initialized' || echo 'not_initialized'"
        $Result = Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot
        
        # Ensure we return a boolean value
        if ([string]::IsNullOrWhiteSpace($Result)) {
            return $false
        }
        
        return $Result -match "initialized"
    }
    catch {
        Write-LogMessage "Error checking pacman-key initialization: $($_.Exception.Message.Trim())" -Level Warning
        return $false
    }
}

function Test-PackageInstalled {
    <#
    .SYNOPSIS
        Checks if a package is installed using pacman.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER PackageName
        The name of the package to check.
    .OUTPUTS
        [bool] True if installed, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$PackageName
    )

    # Pre-condition validation: Check if distribution exists first
    if (-not (Test-DistributionExists -DistroName $DistroName)) {
        Write-LogMessage "Cannot check package '$PackageName' - distribution '$DistroName' does not exist" -Level Warning
        return $false
    }

    try {
        $null = Invoke-WSLCommand -DistroName $DistroName -Command "pacman -Qi $PackageName" -AsRoot -Quiet
        return $LASTEXITCODE -eq 0
    }
    catch {
        return $false
    }
}

function Test-Chezmoi {
    <#
    .SYNOPSIS
        Checks if the chezmoi command is available on WSL.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .OUTPUTS
        [bool] True if chezmoi is available, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    
    # Pre-condition validation: Check if distribution exists first
    if (-not (Test-DistributionExists -DistroName $DistroName)) {
        Write-LogMessage "Cannot check chezmoi availability - distribution '$DistroName' does not exist" -Level Warning
        return $false
    }
    
    try {
        $Command = "command -v chezmoi >/dev/null 2>&1 && echo 'available' || echo 'not_available'"
        $Result = Invoke-WSLCommand -DistroName $DistroName -Command $Command -AsRoot
        
        # Ensure we return a boolean value
        if ([string]::IsNullOrWhiteSpace($Result)) {
            return $false
        }
        
        return $Result -match "available"
    }
    catch {
        Write-LogMessage "Error checking chezmoi availability: $($_.Exception.Message.Trim())" -Level Warning
        return $false
    }
}

function Test-ChezmoiConfigured {
    <#
    .SYNOPSIS
        Checks if Chezmoi is already configured for the user.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER Username
        The username to check.
    .OUTPUTS
        [bool] True if configured, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Username
    )

    # Pre-condition validation: Check if distribution exists and user exists first
    if (-not (Test-DistributionExists -DistroName $DistroName)) {
        Write-LogMessage "Cannot check Chezmoi configuration for user '$Username' - distribution '$DistroName' does not exist" -Level Warning
        return $false
    }

    if (-not (Test-UserExists -DistroName $DistroName -Username $Username)) {
        Write-LogMessage "Cannot check Chezmoi configuration - user '$Username' does not exist in distribution '$DistroName'" -Level Warning
        return $false
    }

    try {
        $Command = "test -d ~/.local/share/chezmoi && echo 'configured' || echo 'not_configured'"
        $Result = Invoke-WSLCommand -DistroName $DistroName -Command $Command -Username $Username

        # Ensure we return a boolean value
        if ([string]::IsNullOrWhiteSpace($Result)) {
            return $false
        }

        return $Result -match "configured"
    }
    catch {
        return $false
    }
}

function Test-BitwardenAvailable {
    <#
    .SYNOPSIS
        Checks if the Bitwarden CLI (bw) command is available on WSL.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .OUTPUTS
        [bool] True if Bitwarden CLI is available, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName
    )
    Write-LogMessage "Checking Bitwarden CLI availability" -Level Debug
    try {
        Invoke-WSLCommand -DistroName $DistroName -Command "command -v bw" -AsRoot -Quiet
        Write-LogMessage "Bitwarden available" -Level Debug
        return $LASTEXITCODE -eq 0
    }
    catch {
        Write-LogMessage "Error checking Bitwarden CLI availability: $($_.Exception.Message.Trim())" -Level Warning
        return $false
    }
}

# Export functions
Export-ModuleMember -Function Test-ValidLinuxUsername, Test-GitAvailable, Test-DistributionExists,
                              Test-DistributionReady, Test-UserExists, Test-UserSudoAccess,
                              Test-PacmanKeyInitialized, Test-PackageInstalled, Test-Chezmoi, Test-ChezmoiConfigured,
                              Test-BitwardenAvailable
</file>

<file path="pwsh/install_wsl/Install-WSLArchLinux.ps1">
#!/usr/bin/env pwsh

<#
.SYNOPSIS
    Sets up WSL system components and ArchLinux distribution with user creation and sudo configuration.

.DESCRIPTION
    Automates the installation and configuration of WSL and ArchLinux, including:
    - Installing Windows Subsystem for Linux feature
    - Installing Virtual Machine Platform feature
    - Installing WSL2 kernel update
    - Setting WSL2 as default version
    - Prompting for distribution name, image name, and username
    - Removing existing distribution if present
    - Installing the distribution
    - Running initial package manager setup
    - Creating a new user with sudo privileges
    - Configuring passwordless sudo
    - Optional Chezmoi dotfiles management setup
    - Optional SSH port forwarding configuration
    
    When using -Continue, the script will:
    - Skip WSL feature installation
    - Verify the specified distribution exists
    - Check if package manager initialization is needed (sudo availability)
    - Check if user creation is needed
    - Check if Chezmoi setup is needed

.AUTHOR
    Generated script (Refactored)

.EXAMPLE
    .\Install-WSLArchLinux.ps1
    
.EXAMPLE
    .\Install-WSLArchLinux.ps1 -WithChezmoi

.EXAMPLE
    .\Install-WSLArchLinux.ps1 -WithDefaults
    
.EXAMPLE
    .\Install-WSLArchLinux.ps1 -WithDefaults -WithChezmoi

.EXAMPLE
    .\Install-WSLArchLinux.ps1 -Continue -WithDefaults
    Skips WSL installation and works with existing distribution.

.EXAMPLE
    .\Install-WSLArchLinux.ps1 -SSHOnly
    Only configures SSH port forwarding for an existing distribution.

.EXAMPLE
    .\Install-WSLArchLinux.ps1 -SSHOnly -WithDefaults
    Configures SSH port forwarding using default distribution name.

.EXAMPLE
    .\Install-WSLArchLinux.ps1 -DryRun
    Shows what actions would be performed without executing them.

.EXAMPLE
    .\Install-WSLArchLinux.ps1 -DryRun -Debug
    Shows detailed actions with debug information.
#>

#Requires -RunAsAdministrator

param(
    [switch]$WithChezmoi,
    [switch]$WithDefaults,
    [switch]$Continue,
    [switch]$SSHOnly,
    [switch]$Debug,
    [switch]$DryRun
)

# ============================================================================
# Administrative Privileges Check
# ============================================================================

# Check if the script is running with administrator privileges
if (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    Write-Host "Error: This script requires administrator privileges to run." -ForegroundColor Red
    Write-Host "Please right-click the PowerShell script and select 'Run as Administrator' or run it from an elevated PowerShell session." -ForegroundColor Yellow
    exit 1
}

# ============================================================================
# Configuration and Constants
# ============================================================================

$ErrorActionPreference = 'Stop'
$VerbosePreference = 'SilentlyContinue'

# Get current Windows username for default
$WindowsUser = $env:USERNAME
$FirstName = $WindowsUser.Split('.')[0]

# Default values - these are accessible to imported modules
$script:DefaultDistro = 'archlinux'
$script:DefaultName = 'newarchlinux'
$script:DefaultUsername = $FirstName.ToLower()

# Define the packages to be installed/checked - these are accessible to imported modules
$script:PackageManagerPackages = @('archinstall', 'sudo', 'chezmoi', 'bitwarden-cli')

# Timeout and retry constants
$script:DistributionReadyMaxAttempts = 30
$script:DistributionReadyDelaySeconds = 5

# ============================================================================
# Import Modules
# ============================================================================

# Get the script directory
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path

# Create a hashtable to pass parameters to modules
$Global:WSLScriptParams = @{
    Debug = $Debug
    DryRun = $DryRun
    DefaultDistro = $DefaultDistro
    DefaultName = $DefaultName
    DefaultUsername = $DefaultUsername
    PackageManagerPackages = $PackageManagerPackages
    DistributionReadyMaxAttempts = $DistributionReadyMaxAttempts
    DistributionReadyDelaySeconds = $DistributionReadyDelaySeconds
    SSHOnly = $SSHOnly
}

# Import all modules with parameters
Import-Module (Join-Path $ScriptDir "Modules\WSL-Logging.psm1") -Force -ArgumentList $Global:WSLScriptParams
Import-Module (Join-Path $ScriptDir "Modules\WSL-Helpers.psm1") -Force -ArgumentList $Global:WSLScriptParams
Import-Module (Join-Path $ScriptDir "Modules\WSL-SystemSetup.psm1") -Force -ArgumentList $Global:WSLScriptParams
Import-Module (Join-Path $ScriptDir "Modules\WSL-Validation.psm1") -Force -ArgumentList $Global:WSLScriptParams
Import-Module (Join-Path $ScriptDir "Modules\WSL-Command.psm1") -Force -ArgumentList $Global:WSLScriptParams
Import-Module (Join-Path $ScriptDir "Modules\WSL-Management.psm1") -Force -ArgumentList $Global:WSLScriptParams
Import-Module (Join-Path $ScriptDir "Modules\WSL-PackageManager.psm1") -Force -ArgumentList $Global:WSLScriptParams
Import-Module (Join-Path $ScriptDir "Modules\WSL-UserManagement.psm1") -Force -ArgumentList $Global:WSLScriptParams
Import-Module (Join-Path $ScriptDir "Modules\WSL-Input.psm1") -Force -ArgumentList $Global:WSLScriptParams
Import-Module (Join-Path $ScriptDir "Modules\WSL-Chezmoi.psm1") -Force -ArgumentList $Global:WSLScriptParams
Import-Module (Join-Path $ScriptDir "Modules\WSL-SSH.psm1") -Force -ArgumentList $Global:WSLScriptParams
Import-Module (Join-Path $ScriptDir "Modules\WSL-Workflow.psm1") -Force -ArgumentList $Global:WSLScriptParams

# ============================================================================
# Main Function
# ============================================================================

function Main {
    <#
    .SYNOPSIS
        Main entry point for the script.
    #>
    [CmdletBinding()]
    param()

    if ($DryRun) {
        Write-Host ""
        Write-Host "🔍 DRY RUN MODE - No actions will be executed" -ForegroundColor Yellow
        Write-Host "   This is a simulation showing what would be performed" -ForegroundColor Gray
        Write-Host ""
    }

    Write-Section "WSL Distribution Setup"
    Write-LogMessage "Script started with parameters: Continue=$Continue, WithChezmoi=$WithChezmoi, WithDefaults=$WithDefaults, SSHOnly=$SSHOnly, Debug=$Debug" -Level Debug
    
    try {
        # Handle SSHOnly mode
        if ($SSHOnly) {
            Write-Section "SSH Configuration"
            Write-LogMessage "Configuring SSH port forwarding for existing distribution" -Level Info

            # Get distribution name for SSH configuration
            $Config = @{
                DistroName = Get-UserInput -Prompt "Distribution name to configure SSH for" -Default $DefaultName -UseDefault:$WithDefaults
            }

            # Configure SSH
            Invoke-SSHConfiguration -DistroName $Config.DistroName -UseDefaults:$WithDefaults

            Write-LogMessage "SSH configuration completed" -Level Success
            return
        }
        
        # Install WSL features (unless in Continue mode)
        if ($Continue) {
            Write-Section "Configuring Existing Distribution"
        }
        else {
            Write-Section "Installing WSL System Components"
            $RebootRequired = Install-WSLFeatures

            if ($RebootRequired) {
                Write-LogMessage "System restart required to complete WSL installation" -Level Warning
                Write-LogMessage "Restart your computer and run this script again to continue" -Level Info
                return
            }
        }
        
        # Gather configuration
        $Config = Get-ConfigurationInput -ContinueMode:$Continue -UseDefaults:$WithDefaults -WithChezmoi:$WithChezmoi
        
        # Display configuration and confirm
        Show-ConfigurationSummary -Config $Config -ContinueMode:$Continue
        
        if (-not $WithDefaults) {
            $Confirm = Read-Host "Proceed with these settings? (Y/n)"
            if ($Confirm -eq 'n' -or $Confirm -eq 'N') {
                Write-LogMessage "Setup cancelled by user" -Level Warning
                return
            }
        }
        else {
            Write-LogMessage "Proceeding automatically with default settings..." -Level Info
        }
        
        # Execute appropriate workflow
        if ($Continue) {
            Invoke-ContinueModeWorkflow -Config $Config
        }
        else {
            Invoke-NormalModeWorkflow -Config $Config
        }
        
        # Handle Chezmoi setup if requested
        Invoke-ChezmoiWorkflow -Config $Config
        
        # Configure SSH if requested
        Invoke-SSHConfiguration -DistroName $Config.DistroName -UseDefaults:$WithDefaults
        
        # Show completion summary
        Show-CompletionSummary -Config $Config
    }
    catch {
        Write-LogMessage "Setup failed: $($_.Exception.Message)" -Level Error
        Write-LogMessage "Stack trace: $($_.ScriptStackTrace)" -Level Error
        exit 1
    }
}

# Execute main function
Main
</file>

<file path="pwsh/install_wsl/Modules/WSL-Workflow.psm1">
# ============================================================================
# WSL Workflow Module
# ============================================================================

<#
.SYNOPSIS
    Provides workflow orchestration functions for WSL installation.

.DESCRIPTION
    This module contains functions for coordinating the main installation workflows,
    including continue mode, normal mode, Chezmoi setup, and completion summaries.

.PARAMETER Parameters
    Hashtable containing script parameters and configuration values.
#>

# Accept parameters from the main script
param(
    [Parameter(Mandatory)]
    [hashtable]$Parameters
)

# Extract parameters from the hashtable
$script:Debug = $Parameters.Debug
$script:DryRun = $Parameters.DryRun
$script:DefaultDistro = $Parameters.DefaultDistro
$script:DefaultName = $Parameters.DefaultName
$script:DefaultUsername = $Parameters.DefaultUsername
$script:PackageManagerPackages = $Parameters.PackageManagerPackages
$script:DistributionReadyMaxAttempts = $Parameters.DistributionReadyMaxAttempts
$script:DistributionReadyDelaySeconds = $Parameters.DistributionReadyDelaySeconds

# ============================================================================
# Continue Mode Functions
# ============================================================================

function Invoke-ContinueChecks {
    <#
    .SYNOPSIS
        Performs all necessary checks when Continue mode is used.
    .DESCRIPTION
        Verifies distribution exists and checks initialization status of
        package manager, user, and Chezmoi configuration.
    .PARAMETER DistroName
        The name of the distribution to check.
    .PARAMETER Username
        The username to check.
    .PARAMETER UseChezmoi
        Whether to check Chezmoi configuration.
    .OUTPUTS
        [hashtable] Status object with check results.
    #>
    [CmdletBinding()]
    [OutputType([hashtable])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Username,

        [bool]$UseChezmoi
    )

    Write-Section "Checking Existing Distribution"

    # Check if distribution exists and is ready
    if (-not (Test-DistributionExists -DistroName $DistroName)) {
        throw "Distribution '$DistroName' does not exist. Cannot use Continue mode."
    }
    if (-not (Wait-ForDistributionReady -DistroName $DistroName)) {
        throw "Distribution '$DistroName' is not ready. Cannot proceed."
    }

    # Check package manager initialization
    $PackageManagerStatus = Test-PackageManagerInitialized -DistroName $DistroName

    # Check if user exists
    $UserExists = Test-UserExists -DistroName $DistroName -Username $Username

    # Check if Chezmoi is configured (if requested)
    $ChezmoiConfigured = $false
    if ($UseChezmoi -and $UserExists) {
        $ChezmoiConfigured = Test-ChezmoiConfigured -DistroName $DistroName -Username $Username
    }

    # Return status object
    return @{
        PackageManagerStatus = $PackageManagerStatus
        UserExists = $UserExists
        ChezmoiConfigured = $ChezmoiConfigured
    }
}

# ============================================================================
# Main Workflow Functions
# ============================================================================

function Invoke-ContinueModeWorkflow {
    <#
    .SYNOPSIS
        Executes the Continue mode workflow.
    .PARAMETER Config
        Configuration hashtable with user settings.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [hashtable]$Config
    )

    Write-Section "Configuring Existing Distribution"

    # Perform Continue checks
    $Status = Invoke-ContinueChecks -DistroName $Config.DistroName -Username $Config.Username -UseChezmoi $Config.UseChezmoi

    # Handle package manager initialization
    $PackageManagerReady = $Status.PackageManagerStatus.SudoAvailable -and
                          $Status.PackageManagerStatus.KeyringInitialized -and
                          $Status.PackageManagerStatus.AllPackagesInstalled

    if (-not $PackageManagerReady) {
        Write-LogMessage "Initializing package manager..." -Level Info

        # Try to install missing packages first
        if ($Status.PackageManagerStatus.MissingPackages.Count -gt 0) {
            $Result = Install-MissingPackages -DistroName $Config.DistroName -PackageNames $Status.PackageManagerStatus.MissingPackages

            if (-not $Result) {
                Initialize-PackageManager -DistroName $Config.DistroName
            }
        }
        else {
            Initialize-PackageManager -DistroName $Config.DistroName
        }
        Write-LogMessage "Package manager initialized" -Level Success
    }

    # Handle user creation
    if (-not $Status.UserExists) {
        Write-LogMessage "Creating user '$($Config.Username)'..." -Level Info
        New-WSLUser -DistroName $Config.DistroName -Username $Config.Username
        Add-UserToSudoers -DistroName $Config.DistroName -Username $Config.Username
        Write-LogMessage "User created with sudo access" -Level Success
    }
    else {
        if (-not (Test-UserSudoAccess -DistroName $Config.DistroName -Username $Config.Username)) {
            Write-LogMessage "Configuring sudo access for existing user..." -Level Info
            Add-UserToSudoers -DistroName $Config.DistroName -Username $Config.Username
            Write-LogMessage "Sudo access configured" -Level Success
        }
    }

    # Verify configuration
    Test-Configuration -DistroName $Config.DistroName -Username $Config.Username
    Restart-WSLDistribution -DistroName $Config.DistroName
}

function Invoke-NormalModeWorkflow {
    <#
    .SYNOPSIS
        Executes the normal mode workflow (fresh installation).
    .PARAMETER Config
        Configuration hashtable with user settings.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [hashtable]$Config
    )

    Write-Section "Installing WSL Distribution"

    # Show what would be done in dry run mode
    if ($script:DryRun) {
        Write-DryRunAction -Action "install WSL distribution" -Target $Config.DistroImage -Details "name: $($Config.DistroName)"
        Write-DryRunAction -Action "initialize package manager" -Target $Config.DistroName
        Write-DryRunAction -Action "create user" -Target $Config.Username -Details "with sudo access"
        Write-DryRunAction -Action "configure system" -Target $Config.DistroName
        Write-DryRunAction -Action "restart distribution" -Target $Config.DistroName
        return
    }

    Write-ProgressLog -Activity "WSL Setup" -Status "Installing ArchLinux distribution" -PercentComplete 25

    # Install the distribution
    Install-WSLDistribution -ImageName $Config.DistroImage -DistroName $Config.DistroName

    # Verify distribution was registered and ready
    if (-not (Test-DistributionExists -DistroName $Config.DistroName)) {
        throw "Distribution was not successfully registered with WSL"
    }
    if (-not (Wait-ForDistributionReady -DistroName $Config.DistroName)) {
        throw "Distribution failed to become ready"
    }

    Write-LogMessage "Distribution '$($Config.DistroName)' installed successfully" -Level Success
    Write-ProgressLog -Activity "WSL Setup" -Status "Configuring system" -PercentComplete 50

    # Initialize package manager
    Initialize-PackageManager -DistroName $Config.DistroName

    Write-ProgressLog -Activity "WSL Setup" -Status "Creating user account" -PercentComplete 75

    # Create user and configure sudo
    New-WSLUser -DistroName $Config.DistroName -Username $Config.Username
    Add-UserToSudoers -DistroName $Config.DistroName -Username $Config.Username

    Write-LogMessage "User '$($Config.Username)' created with sudo access" -Level Success
    Write-ProgressLog -Activity "WSL Setup" -Status "Finalizing setup" -PercentComplete 100 -Complete

    # Verify configuration
    Test-Configuration -DistroName $Config.DistroName -Username $Config.Username
    Restart-WSLDistribution -DistroName $Config.DistroName
}

function Invoke-ChezmoiWorkflow {
    <#
    .SYNOPSIS
        Executes the Chezmoi setup workflow.
    .PARAMETER Config
        Configuration hashtable with user settings.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [hashtable]$Config
    )

    if (-not $Config.UseChezmoi) {
        return
    }

    # Show what would be done in dry run mode
    if ($script:DryRun) {
        Write-DryRunAction -Action "setup Chezmoi dotfiles" -Target $Config.DistroName -Details "Git: $($Config.GitName) <$($Config.GitEmail)>"
        Write-DryRunAction -Action "open interactive terminal" -Details "for Chezmoi setup"
        return
    }

    Start-Sleep -Seconds 5
    Write-LogMessage "Opening Chezmoi terminal. Script will pause until you complete the setup and close the terminal." -Level Info

    Invoke-ChezmoiSetup -DistroName $Config.DistroName -Username $Config.Username -GitName $Config.GitName -GitEmail $Config.GitEmail -BW_CLIENTSECRET $Config.BW_CLIENTSECRET

    Write-LogMessage "Chezmoi terminal has been closed. Continuing with script execution." -Level Info

    # Verify Chezmoi installation
    if (-not (Test-ChezmoiInstallation -DistroName $Config.DistroName -Username $Config.Username)) {
        Write-LogMessage "Chezmoi installation verification failed" -Level Warning
        Write-Host ""
        Write-Host "Chezmoi verification failed. Some targets may not match their expected state." -ForegroundColor Yellow
        Write-Host "Would you like to:" -ForegroundColor White
        Write-Host "1. Rerun Chezmoi setup" -ForegroundColor Cyan
        Write-Host "2. Continue without verification" -ForegroundColor Yellow
        Write-Host "3. Stop the script" -ForegroundColor Red
        Write-Host ""

        $Choice = Read-Host "Enter your choice (1-3)"

        switch ($Choice) {
            "1" {
                Write-LogMessage "Rerunning Chezmoi setup..." -Level Info
                Invoke-ChezmoiSetup -DistroName $Config.DistroName -Username $Config.Username -GitName $Config.GitName -GitEmail $Config.GitEmail -BW_CLIENTSECRET $Config.BW_CLIENTSECRET
                Write-LogMessage "Chezmoi terminal has been closed. Verifying installation again..." -Level Info
                Start-Sleep -Seconds 3

                # Verify again after rerunning setup
                if (-not (Test-ChezmoiInstallation -DistroName $Config.DistroName -Username $Config.Username)) {
                    Write-LogMessage "Chezmoi installation verification failed after rerunning setup. Stopping script execution." -Level Error
                    throw "Chezmoi installation verification failed"
                }
                Write-LogMessage "Chezmoi installation verified successfully after rerunning setup" -Level Success
            }
            "2" {
                Write-LogMessage "Continuing without Chezmoi verification as requested by user" -Level Warning
            }
            "3" {
                Write-LogMessage "Stopping script execution as requested by user" -Level Error
                throw "Chezmoi installation verification failed - stopped by user"
            }
            default {
                Write-LogMessage "Invalid choice. Stopping script execution." -Level Error
                throw "Chezmoi installation verification failed - invalid user choice"
            }
        }
    }
    else {
        Write-LogMessage "Chezmoi installation verified successfully" -Level Success
    }

    Start-Sleep -Seconds 3

}

function Show-CompletionSummary {
    <#
    .SYNOPSIS
        Displays the final completion summary.
    .PARAMETER Config
        Configuration hashtable with user settings.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [hashtable]$Config
    )

    if ($script:DryRun) {
        Write-Section "Dry Run Complete!"
        Write-Host "🔍 This was a simulation - no actions were executed" -ForegroundColor Yellow
        Write-Host ""
        Write-Host "The following would have been performed:" -ForegroundColor White
        Write-Host "• Install WSL distribution '$($Config.DistroName)'" -ForegroundColor Gray
        Write-Host "• Create user '$($Config.Username)' with sudo access" -ForegroundColor Gray
        if ($Config.UseChezmoi) {
            Write-Host "• Setup Chezmoi dotfiles" -ForegroundColor Gray
        }
        Write-Host ""
        Write-Host "Run without -DryRun to execute these actions." -ForegroundColor Green
        return
    }

    Write-Section "Complete!"
    Write-Host "✅ WSL ArchLinux setup completed successfully" -ForegroundColor Green
    Write-Host ""
    Write-Host "Distribution: $($Config.DistroName)" -ForegroundColor White
    Write-Host "Username:     $($Config.Username)" -ForegroundColor White
    Write-Host ""
    Write-Host "Connect with:" -ForegroundColor Gray
    Write-Host "  wsl -d $($Config.DistroName) -u $($Config.Username)" -ForegroundColor Cyan
    Write-Host ""

    # Ask if user wants to set this distribution as default
    Write-Host "Set '$($Config.DistroName)' as default WSL distribution? (Y/n)" -ForegroundColor Yellow
    $SetDefault = Read-Host

    if ($SetDefault -ne 'n' -and $SetDefault -ne 'N') {
        try {
            Set-WSLDefaultDistribution -DistroName $Config.DistroName
            Write-LogMessage "Default distribution set" -Level Success
        }
        catch {
            Write-LogMessage "Failed to set default distribution: $($_.Exception.Message)" -Level Warning
        }
    }
}

# Export functions
Export-ModuleMember -Function Invoke-ContinueChecks, Invoke-ContinueModeWorkflow,
                              Invoke-NormalModeWorkflow, Invoke-ChezmoiWorkflow,
                              Show-CompletionSummary
</file>

<file path="dot_config/fish/config.fish">
if status is-interactive
    #set fish_tmux_autostart true
    fastfetch
end

# env
source ~/.env

# aliases
source ~/.aliases

# starship prompt
# starship init fish | source

# oh my posh prompt
oh-my-posh init fish --config powerlevel10k_lean | source

# zoxide & fish
zoxide init fish | source
</file>

<file path=".chezmoiscripts/run_onchange_enable_ssh_service.sh.tmpl">
#!{{ lookPath "bash" }}
set -uo pipefail

# Source common functions
source "{{ .chezmoi.sourceDir }}/.chezmoiscripts/common.sh"

# Configuration
readonly SSH_PORT="4444"
readonly SSHD_CONFIG="/etc/ssh/sshd_config"
readonly TMP_DIR="$HOME/.tmp"

# Check if systemd is available
has_systemd() {
    command_exists systemctl && [[ -d /run/systemd/system ]]
}

# Backup file with timestamp
backup_file() {
    local file="$1"
    local filename=$(basename "$file")
    local backup="$TMP_DIR/${filename}.backup.$(date +%Y%m%d_%H%M%S)"
    
    # Create $TMP_DIR if it doesn't exist
    if [[ ! -d "$TMP_DIR" ]]; then
        mkdir -p "$TMP_DIR"
        log_info "Created temporary directory: $TMP_DIR"
    fi
    
    if [[ -f "$file" ]]; then
        cp "$file" "$backup"
        log_info "Backup created: $backup"
        echo "$backup"
    fi
}

# Validate SSH configuration
validate_sshd_config() {
    if ! command_exists sshd; then
        log_error "sshd not found"
        return 1
    fi
    
    sudo sshd -t 2>&1
}

# Check if SSH is listening on port
check_ssh_port() {
    local port="$1"
    local max_attempts=10
    local attempt=0
    
    # Check if we have the required tools
    if ! command_exists ss && ! command_exists netstat; then
        log_warning "Neither ss nor netstat available, cannot verify port"
        return 0  # Assume success
    fi
    
    while [[ $attempt -lt $max_attempts ]]; do
        if command_exists ss; then
            if ss -tlnp 2>/dev/null | grep -q ":${port}.*LISTEN"; then
                return 0
            fi
        elif command_exists netstat; then
            if netstat -tlnp 2>/dev/null | grep -q ":${port}.*LISTEN"; then
                return 0
            fi
        fi
        sleep 1
        ((attempt++))
    done
    return 1
}

create_sshd_config() {
    log_info "Creating SSH configuration..."
    
    sudo tee "$SSHD_CONFIG" > /dev/null << 'SSHD_EOF'
# SSH Daemon Configuration
# Port configuration
Port 4444
ListenAddress 0.0.0.0

# Protocol
Protocol 2

# Host keys
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
HostKey /etc/ssh/ssh_host_ed25519_key

# Logging
SyslogFacility AUTH
LogLevel INFO

# Authentication settings
LoginGraceTime 120
PermitRootLogin no
StrictModes yes

# Public key authentication (disabled)
PubkeyAuthentication yes

# Password authentication (enabled)
PasswordAuthentication no
PermitEmptyPasswords no

# Challenge response authentication
ChallengeResponseAuthentication no

# Use PAM authentication
UsePAM yes

# Allow all users
AllowUsers *

# Connection settings
ClientAliveInterval 300
ClientAliveCountMax 2
MaxAuthTries 6
MaxSessions 10

# Security settings
X11Forwarding no
PrintMotd no
TCPKeepAlive yes

# Subsystem configuration
Subsystem sftp internal-sftp
SSHD_EOF
    
    sudo chmod 644 "$SSHD_CONFIG"
    log_success "SSH configuration created"
}

configure_sshd() {
    log_header "Configuring SSH Service"
    
    # Check for systemd
    if ! has_systemd; then
        log_error "systemd not available - cannot manage SSH service"
        return 1
    fi
    
    # Backup existing configuration
    if [[ -f "$SSHD_CONFIG" ]]; then
        backup_file "$SSHD_CONFIG"
    fi
    
    # Create SSH configuration
    create_sshd_config
    
    # Generate host keys
    log_info "Generating SSH host keys..."
    if sudo ssh-keygen -A 2>/dev/null; then
        log_success "SSH host keys generated"
    else
        log_warning "SSH host key generation had issues (may already exist)"
    fi
    
    # Validate configuration
    log_info "Validating SSH configuration..."
    if ! validate_sshd_config; then
        log_error "SSH configuration is invalid"
        sudo sshd -t
        return 1
    fi
    log_success "SSH configuration is valid"
    
    # Enable SSH service
    log_info "Enabling SSH service to start on boot..."
    if sudo systemctl enable sshd 2>/dev/null; then
        log_success "SSH service enabled"
    else
        log_warning "Could not enable SSH service"
    fi
    
    # Start SSH service
    log_info "Starting SSH service..."
    if sudo systemctl restart sshd; then
        log_success "SSH service started"
    else
        log_error "Failed to start SSH service"
        sudo systemctl status sshd --no-pager
        return 1
    fi
    
    # Verify service is running
    if ! sudo systemctl is-active --quiet sshd; then
        log_error "SSH service is not running"
        sudo systemctl status sshd --no-pager
        return 1
    fi
    log_success "SSH service is running"
    
    # Check port
    log_info "Verifying SSH is listening on port $SSH_PORT..."
    if check_ssh_port "$SSH_PORT"; then
        log_success "SSH is listening on port $SSH_PORT"
    else
        log_warning "Cannot verify SSH is listening on port $SSH_PORT"
        log_info "Checking all SSH ports..."
        if command_exists ss; then
            sudo ss -tlnp | grep sshd || true
        elif command_exists netstat; then
            sudo netstat -tlnp | grep sshd || true
        fi
    fi
    
    log_header "SSH Service Configuration Completed"
    echo ""
    sudo systemctl status sshd --no-pager --lines=3
}

# Copy SSH public key to remote WSL instance via Samba
generate_ssh_key() {
    local ssh_key="${HOME}/.ssh/id_ed25519"  # Private key (no .pub)
    local ssh_pub_key="${ssh_key}.pub"
    log_header "Generating SSH key"
    
    # Generate SSH key if it doesn't exist
    if [[ ! -f "$ssh_pub_key" ]]; then
        log_info "SSH public key not found, generating new key..."
        
        # Create .ssh directory if needed
        mkdir -p "${HOME}/.ssh"
        chmod 700 "${HOME}/.ssh"
        
        # Generate ed25519 key without passphrase
        if ssh-keygen -t ed25519 -f "$ssh_key" -N "" -C "${USER}@$(hostname)"; then
            log_success "SSH key generated: $ssh_key"
        else
            log_error "Failed to generate SSH key"
            return 1
        fi
    else
        log_info "Found SSH public key: $ssh_key"
    fi
    
    # Read the public key content
    local pub_key_content
    pub_key_content=$(cat "$ssh_pub_key")
    
    log_info "Public key:"
    echo "$pub_key_content"
}

main() {
    if is_arch; then
        configure_sshd
    elif is_android; then
        generate_ssh_key
    fi
}
main "$@"
</file>

<file path=".install-essentials.sh">
#!/bin/bash
</file>

<file path="pwsh/install_wsl/Modules/WSL-Chezmoi.psm1">
# ============================================================================
# WSL Chezmoi Module
# ============================================================================

<#
.SYNOPSIS
    Provides Chezmoi dotfiles management functions for WSL distributions.

.DESCRIPTION
    This module contains functions for setting up Chezmoi, managing git configuration,
    and verifying Chezmoi installations.

.PARAMETER Parameters
    Hashtable containing script parameters and configuration values.
#>

# Accept parameters from the main script
param(
    [Parameter(Mandatory)]
    [hashtable]$Parameters
)

# Extract parameters from the hashtable
$script:Debug = $Parameters.Debug
$script:DefaultDistro = $Parameters.DefaultDistro
$script:DefaultName = $Parameters.DefaultName
$script:DefaultUsername = $Parameters.DefaultUsername
$script:PackageManagerPackages = $Parameters.PackageManagerPackages
$script:DistributionReadyMaxAttempts = $Parameters.DistributionReadyMaxAttempts
$script:DistributionReadyDelaySeconds = $Parameters.DistributionReadyDelaySeconds

# ============================================================================
# Chezmoi Functions
# ============================================================================

function Get-GitConfig {
    <#
    .SYNOPSIS
        Retrieves git configuration values from the local system.
    .PARAMETER ConfigKey
        The git config key to retrieve (e.g., "user.name").
    .OUTPUTS
        [string] The configuration value or null if not found.
    #>
    [CmdletBinding()]
    [OutputType([string])]
    param(
        [Parameter(Mandatory)]
        [string]$ConfigKey
    )
    
    if (-not (Test-GitAvailable)) {
        return $null
    }
    
    try {
        $Value = git config --global --get $ConfigKey 2>$null
        return $Value
    }
    catch {
        return $null
    }
}

function Test-ChezmoiInstallation {
    <#
    .SYNOPSIS
        Verifies that Chezmoi was installed successfully.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER Username
        The username to check.
    .OUTPUTS
        [bool] True if Chezmoi is installed and verified, false otherwise.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Username
    )
    
    Write-Section "Verifying Chezmoi Installation"
    
    try {
        Write-LogMessage "Checking if Chezmoi directory exists..." -Level Info
        
        $Command = "test -d ~/.local/share/chezmoi/ && echo 'exists' || echo 'not_found'"
        $Result = Invoke-WSLCommand -DistroName $DistroName -Command $Command -Username $Username -Quiet
        
        if ($Result -notmatch "exists") {
            Write-LogMessage "Chezmoi installation failed - ~/.local/share/chezmoi/ directory not found" -Level Error
            return $false
        }
        
        Write-LogMessage "Chezmoi directory exists, running 'chezmoi verify'..." -Level Info
        
        # Run chezmoi verify and check exit code
        $VerifyCommand = "chezmoi verify >/dev/null 2>&1 && echo 'verify_success' || echo 'verify_failed'"
        $VerifyResult = Invoke-WSLCommand -DistroName $DistroName -Command $VerifyCommand -Username $Username -Quiet
        
        if ($VerifyResult -match "verify_success") {
            Write-LogMessage "Chezmoi installation verified - all targets match their target state" -Level Success
            return $true
        }
        else {
            Write-LogMessage "Chezmoi verification failed - some targets do not match their target state" -Level Warning
            return $false
        }
    }
    catch {
        Write-LogMessage "Failed to verify Chezmoi installation: $($_.Exception.Message.Trim())" -Level Error
        return $false
    }
}

function Invoke-ChezmoiSetup {
    <#
    .SYNOPSIS
        Opens a terminal window for Chezmoi setup.
    .PARAMETER DistroName
        The name of the WSL distribution.
    .PARAMETER Username
        The username to run as.
    .PARAMETER GitName
        Git username for Chezmoi.
    .PARAMETER GitEmail
        Git email for Chezmoi.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$DistroName,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Username,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$GitName,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$GitEmail,
        
        [Parameter()]
        [string]$BW_CLIENTSECRET
    )
    
    $ChezmoiCommand = "chezmoi init --apply $GitName --promptString `"GitHub\ username=$GitName`" --promptString `"GitHub\ email=$GitEmail`""
    # Validate Bitwarden CLI is available before proceeding
    if ((Test-BitwardenAvailable -DistroName $DistroName) -and $BW_CLIENTSECRET) {
        Write-LogMessage "Bitwarden CLI (bw) is available and client secret provided." -Level Info
        $ChezmoiCommand = "export BW_CLIENTID=`"user.e4878fd7-8be5-4510-b457-ac6a00a44fff`" && export BW_CLIENTSECRET=`"$BW_CLIENTSECRET`" && export BW_SESSION=`$(bw login --apikey) && chezmoi init --apply $GitName --promptString `"GitHub\ username=$GitName`" --promptString `"GitHub\ email=$GitEmail`""
    }

    Write-LogMessage "Starting Windows Terminal with Chezmoi setup" -Level Info
    Write-LogMessage "Chezmoi command: $ChezmoiCommand" -Level Debug
    Write-Host ""
    
    Invoke-WSLCommandInteractive -DistroName $DistroName -Command $ChezmoiCommand -Username $Username
    
    Write-LogMessage "Chezmoi terminal completed" -Level Success
}

# Export functions
Export-ModuleMember -Function Get-GitConfig, Test-ChezmoiInstallation, Invoke-ChezmoiSetup
</file>

<file path=".chezmoidata/packages.yaml">
packages:
  linux:
    arch:
      npm:
        - "@musistudio/claude-code-router"
      pacman:
        - openssh
        - net-tools
        - git
        - curl
        - grep
        - gawk
        - jq
        - deno
        - base-devel
        - procps-ng 
        - file
        - fontconfig
      brew:
        # Development
        - node
        - python
        - ruby
        - golang
        - rust
        # Build tools
        #- cmake
        #- make
        # Version control & tools
        - gh  # GitHub CLI
        - lazygit
        # Text editors
        - nano
        - neovim
        - micro
        # Utilities
        - jq
        - yq
        - ripgrep
        - fd
        - fzf
        - bat
        - bat-extras
        - cheat
        - uv
        - htop
        - tlrc
        - eza
        - zoxide
        - fastfetch
        - ggc
        # AI
        - opencode
        - mods
        # Shell
        - zsh
        - tmux
        - fish
        - starship
      casks:
        - claude-code
  android:
    termux:
      pkg:
        - termux-tools
        - gh
        - curl
        - wget
        - git
        - python
        - openssh
        - sudo
        - fastfetch
        - zoxide
        - fish
        - samba
</file>

<file path=".chezmoi.toml.tmpl">
{{- $github_user := "" -}}
{{- $github_email := "" -}}

{{- if eq .chezmoi.os "linux" }}
{{-   $github_user = promptStringOnce . "github_user" "GitHub username" -}}
{{-   $github_email = promptStringOnce . "github_email" "GitHub email" -}}
{{- end }}

[tmpDir]
    path = ".local/share/chezmoi/.tmp"

{{- if ne .chezmoi.os "android" }}
[data]
    github_user = {{ $github_user | quote }}
    github_email = {{ $github_email | quote }}

    OPENROUTER_API_KEY = {{ (bitwardenFields "item" "OPENROUTER_API_KEY").Token.value | quote }}
    GITHUB_TOKEN = {{ (bitwardenFields "item" "GITHUB_TOKEN").Token.value | quote }}
    ZAI_API_KEY = {{ (bitwardenFields "item" "ZAI_API_KEY").Token.value | quote }}

[bitwarden]
    unlock = "auto"
{{- end }}

#[hooks.read-source-state.pre]
#    command = "sh ~/.local/share/chezmoi/.install-essentials.sh"
</file>

<file path="dot_zshrc">
eval "$(starship init zsh)"
# zmodload zsh/zprof  # Add at the top
# =====================================================
#   CORE ZSH OPTIONS
# =====================================================
# Set history options
HISTFILE=$HOME/.zsh_history
HISTSIZE=10000
SAVEHIST=10000
setopt EXTENDED_HISTORY          # Store command timestamp
setopt HIST_EXPIRE_DUPS_FIRST    # Delete duplicates first when HISTFILE size exceeds HISTSIZE
setopt HIST_IGNORE_DUPS          # Don't record an entry that was just recorded
setopt HIST_IGNORE_SPACE         # Don't record entries starting with a space
setopt HIST_FIND_NO_DUPS         # Do not display duplicates when searching
setopt HIST_VERIFY               # Show command with history expansion before running it
setopt INC_APPEND_HISTORY        # Add commands to HISTFILE in order of execution
setopt SHARE_HISTORY             # Share command history data between sessions

# Set magic equal subst for things like --option=value
setopt magicequalsubst

# =====================================================
#   PLUGIN MANAGEMENT (via znap)
# =====================================================
# Initialize znap (lazy plugin manager for zsh)
[[ -r ~/.local/share/znap/znap.zsh ]] || {
    echo "Installing znap plugin manager..."
    mkdir -p ~/.local/share/znap
    git clone --depth 1 -- https://github.com/marlonrichert/zsh-snap.git ~/.local/share/znap
}
source ~/.local/share/znap/znap.zsh

# =====================================================
#   THEME SETUP - POWERLEVEL10K
# =====================================================
# Set up Powerlevel10k theme
# [[ -d ~/.p10k ]] || git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/.p10k
# source ~/.p10k/powerlevel10k.zsh-theme
#Load p10k config file (if it exists)
# [[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# =====================================================
#   MY PLUGINS
# =====================================================
znap source tfpickard/zsh-command-histogram

# =====================================================
#   ESSENTIAL PLUGINS
# =====================================================
# Core prezto modules for basic environment setup
znap source sorin-ionescu/prezto modules/{environment,history}

# Oh My Zsh library modules
znap source ohmyzsh/ohmyzsh lib/{cli,git,theme-and-appearance,directories,functions,grep,history,termsupport}

# =====================================================
#   COMPLETION PLUGINS
# =====================================================
# Enhanced completion with auto-suggestions
znap source marlonrichert/zsh-edit         # Better line editing
znap source zsh-users/zsh-completions      # Additional completion definitions 
# znap source marlonrichert/zsh-autocomplete # Real-time type-ahead completion (loaded first for compatibility)
znap source zsh-users/zsh-autosuggestions  # Fish-like suggestions based on history

# Fuzzy completion plugins
znap source Freed-Wu/fzf-tab-source        # Source for fzf-tab 
znap source Aloxaf/fzf-tab                 # Tab completion with fzf

# =====================================================
#   SYNTAX AND BEHAVIOR PLUGINS
# =====================================================

# History improvements
znap source marlonrichert/zsh-hist         # Better history command with alt-h
znap source zsh-users/zsh-history-substring-search  # Fish-like up/down for history

# Auto-pairing of brackets, quotes, etc.
znap source hlissner/zsh-autopair

# Colors for commands, directories, etc.
znap source marlonrichert/zcolors
znap eval marlonrichert/zcolors "zcolors ${(q)LS_COLORS}"

# Load direnv for automatic environment loading
znap source ptavares/zsh-direnv
eval "$(direnv hook zsh)"

# =====================================================
#   PROJECT MANAGEMENT PLUGINS
# =====================================================
# Auto-switch Python virtualenvs when entering directories
znap source MichaelAquilina/zsh-autoswitch-virtualenv

# tmux configuration and auto-start
ZSH_TMUX_AUTOSTART=${ZSH_TMUX_AUTOSTART:-true}
ZSH_TMUX_AUTOCONNECT=${ZSH_TMUX_AUTOCONNECT:-true}
ts=$(date +"%m-%d-%yT%H:%M:%S")
ZSH_TMUX_DEFAULT_SESSION_NAME=${ZSH_TMUX_DEFAULT_SESSION_NAME:-"tmux-$ts"}
ZSH_TMUX_UNICODE=true
znap source ohmyzsh/ohmyzsh plugins/tmux

# Git-related plugins
znap source ohmyzsh/ohmyzsh plugins/{git,gitfast,git-extras}

# OS-specific plugins
if [[ $(uname) == "Darwin" ]]; then
    znap source ohmyzsh/ohmyzsh plugins/{macos,brew}
else
    # Linux-specific plugins
    znap source ohmyzsh/ohmyzsh plugins/sudo
fi

# =====================================================
#   LEARNING AND PRODUCTIVITY PLUGINS
# =====================================================
# Shows when you should use an existing alias
znap source MichaelAquilina/zsh-you-should-use
# Configure YSU behavior
# export YSU_MESSAGE_FORMAT="💡 $(tput bold)You should use:%B$(tput sgr0) %alias $(tput dim)instead of %command$(tput sgr0)"
# export YSU_MESSAGE_FORMAT="💡 $(tput bold)You should use:%B$(tput sgr0) %alias $(tput dim)instead of %command$(tput sgr0)"
export YSU_MODE=ALL  # Show suggestions for global and git aliases

# Shows ZSH tips and tricks in your terminal
znap source molovo/tipz
# Configure tipz
export TIPZ_TEXT="💡 ZSH Tip: "


# =====================================================
#   KEYBINDINGS AND SHORTCUTS
# =====================================================
# Enable vi mode
znap source ohmyzsh/ohmyzsh plugins/vi-mode

# Push line for editing
bindkey '^[q' push-line-or-edit
bindkey -r '^Q' '^[Q'

# History search with up/down arrows
# bindkey '^[[A' history-substring-search-up
# bindkey '^[[B' history-substring-search-down
bindkey "$terminfo[kcuu1]" history-substring-search-up
bindkey "$terminfo[kcud1]" history-substring-search-down

# =====================================================
#   HISTORY AND SEARCH ENHANCEMENT
# =====================================================
# Install fzf if not already installed
if ! command -v fzf &>/dev/null; then
    echo "Installing fzf for enhanced history search..."
    if [[ $(uname) == "Darwin" ]]; then
        brew install fzf
        $(brew --prefix)/opt/fzf/install --key-bindings --completion --no-update-rc
    else
        git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
        ~/.fzf/install --key-bindings --completion --no-update-rc
    fi
fi

# Load fzf key bindings and completion
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# Enhanced history search with fzf
# This will allow up-arrow to show a multi-line view of matching history
# Based on what you've already typed
function fzf-history-widget() {
    local selected num
    setopt localoptions noglobsubst noposixbuiltins pipefail no_aliases 2> /dev/null
    selected=( $(fc -rl 1 | 
        awk '{ cmd=$0; sub(/^[ \t]*[0-9]+\**[ \t]+/, "", cmd); if (!seen[cmd]++) print $0 }' |
        FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} $FZF_DEFAULT_OPTS -n2..,.. --scheme=history --bind=ctrl-r:toggle-sort,ctrl-z:ignore --query=${(qqq)LBUFFER} +m" $(__fzfcmd)) )
    local ret=$?
    if [ -n "$selected" ]; then
        num=$selected[1]
        if [ -n "$num" ]; then
            zle vi-fetch-history -n $num
        fi
    fi
    zle reset-prompt
    set +x
}
zle -N fzf-history-widget
bindkey '^R' fzf-history-widget
# bindkey '^[[A' fzf-history-widget  # Up arrow for history search
# bindkey '^[OA' fzf-history-widget  # Alternative Up arrow code
bindkey '^[[1;2A' fzf-history-widget  # Up arrow for history search
bindkey '^K' fzf-history-widget  # Alternative Up arrow code

# Don't bind standard up/down keys to history-substring-search
# since we're using fzf-history-widget instead
# =====================================================
#   TOOL INTEGRATIONS AND COMPLETIONS
# =====================================================
[[ -d ~/.config/zsh/completions ]] || mkdir -p ~/.config/zsh/completions
for x in ~/.config/zsh/completions/*; do
    [[ "$x" =~ ".zwc" ]] && continue
    if [[ -f $x ]]; then
        source $x
    fi
done

# Pip completion
znap function _pip_completion pip 'eval "$( pip completion --zsh )"'
compctl -K _pip_completion pip

# Pipx completion
znap function _python_argcomplete pipx 'eval "$( register-python-argcomplete pipx )"'
complete -o nospace -o default -o bashdefault -F _python_argcomplete pipx

# Pipenv completion
znap function _pipenv pipenv 'eval "$( pipenv --completion )"'
compdef _pipenv pipenv

# iTerm2 integration
znap eval iterm2 'curl -fsSL https://iterm2.com/shell_integration/zsh'

# =====================================================
#   PERFORMANCE OPTIMIZATIONS
# =====================================================
znap source romkatv/zsh-defer
znap source mroth/evalcache

# Cache slow evaluations
_evalcache pyenv init -
_evalcache direnv hook zsh

# =====================================================
#   ENHANCED VI MODE AND EDITING
# =====================================================
znap source jeffreytse/zsh-vi-mode
znap source kutsan/zsh-system-clipboard
# znap source olets/zsh-abbr

# =====================================================
#   ADVANCED NAVIGATION AND COMPLETION
# =====================================================
znap eval zoxide 'zoxide init zsh'
znap source zdharma-continuum/fast-syntax-highlighting  # Replace existing
znap source psprint/zsh-navigation-tools

# =====================================================
#   DEVELOPMENT WORKFLOW
# =====================================================
znap source MichaelAquilina/zsh-auto-notify
export AUTO_NOTIFY_THRESHOLD=15  # Notify for long compilations


# Syntax highlighting (must be sourced after completion plugins)
znap source zsh-users/zsh-syntax-highlighting

# =====================================================
#   ENVIRONMENT TOOLS
# =====================================================
# Python environment setup
export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"
if command -v pyenv >/dev/null; then
    eval "$(pyenv init -)"
    export WORKON_HOME="$HOME/.virtualenvs"
    export PIP_VIRTUALENV_BASE="$WORKON_HOME"
    pyenv virtualenvwrapper_lazy
fi

# Node.js environment setup
export NVM_DIR="$HOME/.config/nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # Load nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # Load completion

# pnpm
export PNPM_HOME="$HOME/.local/share/pnpm"
if [ -d "$PNPM_HOME" ]; then
    case ":$PATH:" in
        *":$PNPM_HOME:"*) ;;
        *) export PATH="$PNPM_HOME:$PATH" ;;
    esac
fi

# Go environment setup
export GOPATH="$HOME/go"
export PATH="$GOPATH/bin:$PATH"
#
# # Conda initialization (if installed)
# if [ -f "/opt/homebrew/Caskroom/miniconda/base/bin/conda" ]; then
#     __conda_setup="$('/opt/homebrew/Caskroom/miniconda/base/bin/conda' 'shell.zsh' 'hook' 2> /dev/null)"
#     if [ $? -eq 0 ]; then
#         eval "$__conda_setup"
#     else
#         if [ -f "/opt/homebrew/Caskroom/miniconda/base/etc/profile.d/conda.sh" ]; then
#             . "/opt/homebrew/Caskroom/miniconda/base/etc/profile.d/conda.sh"
#         else
#             export PATH="/opt/homebrew/Caskroom/miniconda/base/bin:$PATH"
#         fi
#     fi
#     unset __conda_setup
# fi
#
# =====================================================
#   PATH CONFIGURATION
# =====================================================
# Add Homebrew to PATH
[[ -d /opt/homebrew/bin ]] && \
    export PATH="/opt/homebrew/bin:/opt/homebrew/opt/gnu-getopt/bin:$PATH"

# Add local bin directories
export PATH="$HOME/.local/bin:$HOME/.local/share/nvim/bin:$PATH"

export LLM_USER_PATH=$HOME/.config/llm
# =====================================================
#   ALIASES AND FUNCTIONS
# =====================================================
# Load aliases from separate files if they exist
[[ -f ~/.aliases ]] && source ~/.aliases
[[ -f ~/.functions ]] && source ~/.functions
[[ -f ~/.exports ]] && source ~/.exports
[[ -f ~/.path ]] && source ~/.path
[[ -f ~/.extra ]] && source ~/.extra

# Modern CLI tool aliases (add to your .aliases file)
alias cat='bat --paging=never'
# alias find='fd'
# alias grep='rg'

# Enhanced ls command with lsd if available
if command -v lsd &>/dev/null; then
    export  EZA_ICONS_AUTO=true
    alias ls="eza"
    alias ll="eza -la"
    alias lh="eza -lah"
    alias la="eza -las newest"
    alias lls="eza -lahs size"
    alias lt="eza --tree"
fi

# Install via brew/paru first, then:
# znap eval zoxide 'zoxide init zsh'
eval "$(zoxide init zsh)"
# Provides 'z' command for intelligent directory jumping
# Improved cd with auto-ls
function cd() {
    command -v z >/dev/null && z "$@" || (echo "install zoxide!"; builtin cd "$@")
    eza
    # z "$@" && ls
}
# zprof  # Add at the bottom (comment out after testing)


if [[ -d ~/.p ]]; then
    pushd $HOME/.p >/dev/null 
    for f in *; do 
        [[ -x $f ]] && source $f
    done
    popd
fi

# Auto-start tmux if not already in tmux
[[ -z $TMUX ]] && exec tmux
</file>

</files>
